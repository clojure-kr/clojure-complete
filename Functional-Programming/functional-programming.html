<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>Funcions and Functional Programming</title>
<link rel="stylesheet" href="../my-asciidoctor.css">
<link rel="stylesheet" href="../coderay-asciidoctor.css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71804757-1', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>Funcions and Functional Programming</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_함수형_언어란_무엇인가">1. 함수형 언어란 무엇인가?</a></li>
<li><a href="#_함수_정의하기">2. 함수 정의하기</a>
<ul class="sectlevel2">
<li><a href="#_defn">2.1. defn</a></li>
<li><a href="#_fn">2.2. fn</a></li>
<li><a href="#_함수_리터럴">2.3. 함수 리터럴: #(&#8230;&#8203;)</a></li>
</ul>
</li>
<li><a href="#_주요_함수들">3. 주요 함수들</a>
<ul class="sectlevel2">
<li><a href="#_mapmapvmap_indexed">3.1. map/mapv/map-indexed</a></li>
<li><a href="#_filterfiltervremove">3.2. filter/filterv/remove</a></li>
<li><a href="#_reducereduce_kvreductions">3.3. reduce/reduce-kv/reductions</a></li>
<li><a href="#_apply">3.4. apply</a></li>
<li><a href="#_keepkeep_indexed">3.5. keep/keep-indexed</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_함수형_언어란_무엇인가">1. 함수형 언어란 무엇인가?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>다음의 조건 네 가지를 충족시키면, 그 함수는 일급 함수(fisrt-class function)라고 부르고,
일급 함수를 지원하는 언어는 '전통적인 의미&#8217;에서의 함수형 언어라고 부를 수 있다.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>함수 객체를 변수에 대입할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">double</span> (<span class="keyword">fn</span> [a] (<span class="keyword">*</span> <span class="integer">2</span> a)))   <span class="comment">; </span><b class="conum">(1)</b>

(<span class="keyword">double</span> <span class="integer">10</span>)    <span class="comment">; =&gt; 20</span>

(<span class="keyword">def</span> <span class="function">double2</span> <span class="keyword">double</span>)

(double2 <span class="integer">10</span>)   <span class="comment">; =&gt; 20</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>특수 함수(special form) <code>fn</code>을 이용해 먼저 함수 객체를 생성한 후, 이 객체를
<code>double</code>이라는 심볼에 바인딩한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>함수 객체를 함수의 인수로 전달할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">calc</span> [op a b]
  (op a b))

(calc <span class="keyword">+</span> <span class="integer">10</span> <span class="integer">20</span>)   <span class="comment">; =&gt; 30   </span><b class="conum">(1)</b>
(calc <span class="keyword">*</span> <span class="integer">10</span> <span class="integer">20</span>)   <span class="comment">; =&gt; 200</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수 객체 <code>+</code>를 <code>calc</code> 함수의 첫 번째 인수로 넘긴다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>함수 객체를 함수의 반환값으로 반환할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">operator</span> [op]
  (<span class="keyword">cond</span>
    (<span class="keyword">=</span> op <span class="symbol">:plus</span>)  <span class="keyword">+</span>     <span class="comment">; </span><b class="conum">(1)</b>
    (<span class="keyword">=</span> op <span class="symbol">:minus</span>) <span class="keyword">-</span>))   <span class="comment">; </span><b class="conum">(1)</b>

((operator <span class="symbol">:plus</span>) <span class="integer">10</span> <span class="integer">20</span>)    <span class="comment">; =&gt; 30</span>
((operator <span class="symbol">:minus</span>) <span class="integer">10</span> <span class="integer">20</span>)   <span class="comment">; =&gt; -10</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수 객체 <code>+</code> 또는 <code>-</code>를 함수의 반환값으로 반환한다.</p>
</li>
</ol>
</div>
</li>
<li>
<p>함수 객체를 동적으로 생성할 수 있다.</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">multiple</span> [n]
  (<span class="keyword">fn</span> [a]   <span class="comment">; </span><b class="conum">(1)</b>
    (<span class="keyword">*</span> n a)))

(<span class="keyword">def</span> <span class="function">double</span> (multiple <span class="integer">2</span>))
<span class="comment">; =&gt; #&lt;Var@4340684b: #object[user$multiple$fn__12286 0x26a894a2]&gt;</span>

(<span class="keyword">def</span> <span class="function">triple</span> (multiple <span class="integer">3</span>))
<span class="comment">; =&gt; #&lt;Var@fc4d31e: #object[user$multiple$fn__12286 0x1a4b7c5d]&gt;</span>

(<span class="keyword">double</span> <span class="integer">10</span>)   <span class="comment">; =&gt; 20</span>
(triple <span class="integer">10</span>)   <span class="comment">; =&gt; 30</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수를 동적으로 생성해 반환한다. 특수 함수 <code>fn</code>이 수행될 때마다 새로운 함수 객체가
생성된다.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
특히 위의 두 번째와 세 번째 조건을 충족시키는 함수를 고차 함수(higher-order
     function)라고 부른다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>오늘날 대부분의 언어가 함수형 언어의 영향을 받아, 위의 네 가지 조건을 모두 지원하거나
일부를 지원하고 있다. 그래서 루비나 파이썬, 심지어는 자바스크립트 언어마저도 위의 조건들을
모두 충족하고 있다. 그렇다면 이 세상은 이미 함수형 언어가 지배하고 있는 것인가? 함수형
언어를 어떻게 정의하느냐에 따라 의견이 달라질 수 있겠지만, 클로저 언어의 입장에서는 그렇게
보지 않는다. '현대적인 의미&#8217;에서, 즉 진정한 의미에서의 함수형 언어는 위의 네 가지 조건
이외에 한 가지 조건을 더 충족시켜야 하는데, 그것은 바로 클로저나 해스켈처럼
불변형(immutable) 자료 구조를 기본적으로 지원해야 한다는 것이다.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_함수_정의하기">2. 함수 정의하기</h2>
<div class="sectionbody">
<div class="paragraph">
<p>이제 함수를 직접 정의해 보자.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="sect2">
<h3 id="_defn">2.1. defn</h3>
<div class="paragraph">
<p>클로저에서 함수를 정의하는 가장 일반적인 방법은 <code>defn</code>을 이용하는 것이다.</p>
</div>
<div class="listingblock">
<div class="title">defn</div>
<div class="content">
<pre>(defn name doc-string? metadata-map? [params*] prepost-map? body)
(defn name doc-string? metadata-map? ([params*] prepost-map? body)+)

prepost-map := {:pre  [pre-expr+]
                :post [post-expr+]}</pre>
</div>
</div>
<div class="paragraph">
<p>좀 복잡하게 보인다. 그래서 가장 간단한 예부터 차근차근 설명해 보겠다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">foo</span>                   <span class="comment">; </span><b class="conum">(1)</b>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">세 개의 숫자를 곱한다.</span><span class="delimiter">&quot;</span></span>   <span class="comment">; </span><b class="conum">(2)</b>
  [a b c]                   <span class="comment">; </span><b class="conum">(3)</b>
  (<span class="keyword">*</span> a b c))                <span class="comment">; </span><b class="conum">(4)</b>

(foo <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>)   <span class="comment">;=&gt; 24</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수의 이름(name)이다.</p>
</li>
<li>
<p>함수를 설명하는 doc-string이다.</p>
</li>
<li>
<p>함수의 인수들(params)이다.</p>
</li>
<li>
<p>함수의 몸체(body)이다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>같은 이름을 사용하지만, 인수의 개수를 달리한 함수 본체를 여러 개 정의할 수도 있다. 이때
정의된 함수들 중에서 어떤 함수 본체가 호출될지는 오직 인수의 개수에 의해서만 결정이 되고,
타입은 전혀 고려의 대상이 아니다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">foo</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">숫자를 곱한다.</span><span class="delimiter">&quot;</span></span>
  ([a b]                                   <span class="comment">; </span><b class="conum">(1)</b>
   (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Called with 2 arguments.</span><span class="delimiter">&quot;</span></span>)
   (<span class="keyword">*</span> a b))
  ([a b c]                                 <span class="comment">; </span><b class="conum">(2)</b>
   (<span class="keyword">println</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Called with 3 arguments.</span><span class="delimiter">&quot;</span></span>)
   (<span class="keyword">*</span> a b c)))

(foo <span class="integer">2</span> <span class="integer">3</span>)
<span class="comment">;&gt;&gt; Called with 2 arguments.</span>
<span class="comment">;=&gt; 6</span>

(foo <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>)
<span class="comment">;&gt;&gt; Called with 3 arguments.</span>
<span class="comment">;=&gt; 24</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>두 개의 인수가 주어질 때 호출되는 함수를 정의한다.</p>
</li>
<li>
<p>세 개의 인수가 주어질 때 호출되는 함수를 정의한다.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_metadata_map을_사용한_경우">2.1.1. metadata-map을 사용한 경우</h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">greet</span>
  <span class="string"><span class="delimiter">&quot;</span><span class="content">인사말을 전한다.</span><span class="delimiter">&quot;</span></span>                 <span class="comment">; </span><b class="conum">(1)</b>
  {<span class="symbol">:tag</span> String <span class="symbol">:other-meta-data</span> <span class="integer">5</span>}   <span class="comment">; </span><b class="conum">(2)</b>
  [<span class="keyword">name</span>]
  (<span class="keyword">format</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello, %s</span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))

(<span class="keyword">meta</span> <span class="error">#</span>'greet)
<span class="comment">;=&gt; {:arglists ([name]), :tag java.lang.String, :other-meta-data 5, :line 10,</span>
<span class="comment">;    :column 6, :file &quot;*cider-repl localhost:53283*&quot;, :name greet, :ns #namespace[user]}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>함수의 doc-string이다.</p>
</li>
<li>
<p>함수의 <code>metadata-map</code>이다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>위의 코드는 아래의 코드와 동일한 결과를 낳는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> ^{<span class="symbol">:tag</span> String <span class="symbol">:other-meta-data</span> <span class="integer">5</span>}   <span class="comment">; </span><b class="conum">(1)</b>
  greet
  [<span class="keyword">name</span>]
  (<span class="keyword">format</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello, %s</span><span class="delimiter">&quot;</span></span> <span class="keyword">name</span>))

(<span class="keyword">meta</span> <span class="error">#</span>'greet)
<span class="comment">;=&gt; {:tag java.lang.String, :other-meta-data 5, :arglists ([name]), :line 15,</span>
<span class="comment">;    :column 6, :file &quot;*cider-repl localhost:53283*&quot;, :name greet2, :ns #namespace[user]}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>var인 greet에 대한 metadata map이다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>결과적으로 var인 <code>greet</code>에 대한 metadata를 표기하는 방식을 두 가지 제공하고 있는
셈이다. 그런데 실제로는 metadata를 표시할 때, 첫 번쨰 방식보다는 두 번쨰째 방식이 더 많이
사용된다. 하지만, 표시해야 하는 metadata의 내용이 아주 많은 경우에는 첫 번째 방식이 두
번째 방식보다 코드가 더 깔끔하게 보이는 장점은 있다.</p>
</div>
</div>
<div class="sect3">
<h4 id="_prepost_map을_사용한_경우">2.1.2. prepost-map을 사용한 경우</h4>
<div class="paragraph">
<p><code>:pre</code> 뒤에는 함수를 실행하기 전에 그 인수를 검사(validation)하는 식들이 벡터 기호 안에
나열될 수 있다. <code>:post</code> 뒤에는 함수가 반환한 값(이 값은 <code>%</code>로 표기한다)을 검사하는
식들이 벡터 기호 안에 나열될 수 있다. <code>:pre</code>와 <code>:post</code> 둘 중에 한 개만 올 수도
있다. 이 검사는 <code>*assert*</code>의 값이 <code>true</code>일 때만 실행되고, <code>false</code>일 때는 실행되지
않는다. 게다가 이 검사는 내부적으로 <code>assert</code> 매크로를 이용해 구현되어 있어서,
<code>*assert*</code>의 값이 <code>false</code>일 때는 아무것으로도 확장되지 않아, 실행시 아무런 부하도
일으키지 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">*assert*   <span class="comment">;=&gt; true</span>

(<span class="keyword">defn</span> <span class="function">constrained-fn</span> [f x]
  {<span class="symbol">:pre</span>  [(<span class="keyword">pos?</span> x) (<span class="keyword">integer?</span> x)]
   <span class="symbol">:post</span> [(<span class="keyword">=</span> % (<span class="keyword">*</span> <span class="integer">2</span> x)) (<span class="keyword">integer?</span> %)]}
  (f x))

(constrained-fn #(<span class="keyword">*</span> <span class="integer">2</span> %) <span class="integer">2</span>)
<span class="comment">;=&gt; 4</span>

(constrained-fn #(<span class="keyword">*</span> <span class="integer">2</span> %) <span class="integer">-2</span>)
<span class="comment">;&gt;&gt; AssertionError Assert failed: (pos? x)</span>

(constrained-fn #(<span class="keyword">*</span> <span class="integer">2</span> %) <span class="float">2.0</span>)
<span class="comment">;&gt;&gt; AssertionError Assert failed: (integer? x)</span>

(constrained-fn #(<span class="keyword">*</span> <span class="integer">3</span> %) <span class="integer">2</span>)
<span class="comment">;&gt;&gt; AssertionError Assert failed: (= % (* 2 x))</span>

<span class="comment">;; *assert*를 false로 설정한다.</span>
(set! *assert* <span class="predefined-constant">false</span>)
*assert*   <span class="comment">;=&gt; false</span>

<span class="comment">;; constrained-fn을 재컴파일해 주어야 한다. 검사할 때 내부적으로 이용되는 assert는</span>
<span class="comment">;; 매크로이고, 매크로 확장은 컴파일 이전에 이루어지기 때문이다.</span>
(<span class="keyword">defn</span> <span class="function">constrained-fn</span> [f x]
  {<span class="symbol">:pre</span>  [(<span class="keyword">pos?</span> x) (<span class="keyword">integer?</span> x)]
   <span class="symbol">:post</span> [(<span class="keyword">=</span> % (<span class="keyword">*</span> <span class="integer">2</span> x)) (<span class="keyword">integer?</span> %)]}
  (f x))

<span class="comment">;; 이번에는 검사를 하지 않아 예외가 발생하지 않았다.</span>
(constrained-fn #(<span class="keyword">*</span> <span class="integer">2</span> %) <span class="integer">-2</span>)
<span class="comment">;=&gt; -4</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defn_2">2.1.3. defn-</h4>
<div class="paragraph">
<p><code>defn-</code>로 함수를 정의하면, 이 함수는 해당 이름공간 내에서만 호출할 수 있는 함수가 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">user&gt;(<span class="keyword">defn-</span> <span class="function">private-add</span> [a b]
        (<span class="keyword">+</span> a b))
<span class="error">#</span>'user/private-add

user&gt;  (private-add <span class="integer">5</span> <span class="integer">6</span>)
<span class="integer">11</span>

user&gt; (<span class="keyword">ns</span> <span class="namespace">my-new-namespace</span>)
<span class="predefined-constant">nil</span>

my-new-namespace&gt; (user/private-add <span class="integer">7</span> <span class="integer">8</span>)     <span class="comment">; </span><b class="conum">(1)</b>
CompilerException java.lang.IllegalStateException<span class="error">:</span> <span class="keyword">var</span><span class="error">:</span> <span class="error">#</span>'user/private-add is <span class="keyword">not</span> public

my-new-namespace&gt; (<span class="error">#</span>'user/private-add <span class="integer">7</span> <span class="integer">8</span>)   <span class="comment">; </span><b class="conum">(2)</b>
<span class="integer">15</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>user/private-add</code> 함수는 <code>user</code> 이름공간 밖에서는 호출할 수 없다.</p>
</li>
<li>
<p>하지만 `user/private-add`의 var<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>를 통해서는
호출할 수 있다. 이것은 private 함수도 Unit Test를 실행할 때는 외부 이름공간에서
테스트될 필요가 있기 때문에 허용하고 있다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>그리고 다음의 두 코드는 완전히 같은 일을 수행한다. 다시 말해, <code>(defn- &#8230;&#8203;)</code>는 <code>(defn
^:private &#8230;&#8203;)</code>의 구문 단축형(syntactic sugar)이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn-</span> <span class="function">private-add</span> [a b]
  (<span class="keyword">+</span> a b))

(<span class="keyword">defn</span> ^<span class="symbol">:private</span> private-add
  [a b]
  (<span class="keyword">+</span> a b))</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fn">2.2. fn</h3>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">fn 특수 형식</div>
<div class="content">
<pre>(fn name? [params*] prepost-map? exprs*)
(fn name? ([params*] prepost-map? exprs*)+)</pre>
</div>
</div>
<div class="paragraph">
<p><code>fn</code>은 무명(anonymous)<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>의 함수 객체를 생성하는 클로저의 특수 형식(special forms)이다.</p>
</div>
<div class="paragraph">
<p><code>defn</code>으로 함수를 다음과 같이 정의하면</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">add</span> [a b] (<span class="keyword">+</span> a b))</code></pre>
</div>
</div>
<div class="paragraph">
<p>실제로는 다음과 같은 방식<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>으로 두 단계로 나뉘어 처리된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">add</span>                   <span class="comment">; </span><b class="conum">(2)</b>
  (<span class="keyword">fn</span> [a b] (<span class="keyword">+</span> a b)))      <span class="comment">; </span><b class="conum">(1)</b>

(add <span class="integer">1</span> <span class="integer">2</span>)   <span class="comment">;=&gt; 3            </span><b class="conum">(3)</b>
(add <span class="integer">3</span> <span class="integer">4</span>)   <span class="comment">;=&gt; 7            </span><b class="conum">(3)</b>

((<span class="keyword">fn</span> [a b] (<span class="keyword">*</span> a b)) <span class="integer">2</span> <span class="integer">3</span>)   <span class="comment">; </span><b class="conum">(4)</b>
<span class="comment">;=&gt; 6</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>fn</code>으로 무명의 함수 객체를 생성한다.</p>
</li>
<li>
<p>생성된 무명의 함수 객체에 이름을 부여한다.</p>
</li>
<li>
<p>이름이 부여된 함수는 같은 이름으로 여러 번 호출될 수 있다.</p>
</li>
<li>
<p>여기서 <code>fn</code>으로 생성된 함수는 이름이 없으므로, 다른 곳에서는 호출될 수 없고
이곳에서만 호출된 후 적절한 시점에 garbage collecting된다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>위의 <code>fn</code> 특수 형식의 구문을 설명한 부분을 보면, <code>fn</code>이 무명의 함수 객체를 생성하는 일을
맡고 있음에도 불구하고, 선택적으로 이름을 붙일 수 있게 해 놓은 것을 알 수 있다. 무명
함수가 이름을 가질 수 있다니 대체 이게 무슨 일이란 말인가 하고 생각할 수도 있지만, 그만한
이유는 있다.</p>
</div>
<div class="paragraph">
<p>첫 번째 이유는, <code>fn</code>으로 정의한 함수가 <code>fn</code> 함수 내에서 자기 자신을 호출해야 하는 경우가
종종 있기 때문이다. 이때 이름이 없다면 자기 자신을 다시 호출할 방법이 없게 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">((<span class="keyword">fn</span> fact [x]
   (<span class="keyword">if</span> (<span class="keyword">=</span> x <span class="integer">0</span>)
     <span class="integer">1</span>
     (<span class="keyword">*</span> x (fact (<span class="keyword">dec</span> x)))))
 <span class="integer">5</span>)
<span class="comment">;=&gt; 120</span>

(fact <span class="integer">5</span>)   <span class="comment">; </span><b class="conum">(1)</b>
<span class="comment">;&gt;&gt; CompilerException java.lang.RuntimeException: Unable to resolve symbol: fact in this context,</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>fn</code> 안에서 지정한 익명 함수 이름 <code>fact</code>는 이 함수 안에서만 유효하다. 이 함수 밖에서
호출해서 예외가 발생했다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>두 번째 이유는, 하나의 파일 안에서 <code>fn</code>으로 정의한 무명 함수가 여러 개 있는데, 그 중에
하나에서 에러가 발생하면, 디버깅할 때 어느 무명 함수에서 에러가 발생했는지 구분하기가
힘들어진다. 이런 경우에 매 무명 함수마다 이름을 지정해 놓으면, 에러 메시지에 그 이름을
함께 출력해 주므로 디비깅할 때 도움이 될 수 있기 때문이다. 예를 통해 확인해 보자.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">reduce</span> (<span class="keyword">fn</span> [<span class="keyword">num</span>] (<span class="keyword">inc</span> <span class="keyword">num</span>)) [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])     <span class="comment">; </span><b class="conum">(1)</b>
(<span class="keyword">filter</span> (<span class="keyword">fn</span> [<span class="keyword">num</span>] (<span class="keyword">even?</span> <span class="keyword">num</span>)) [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
<span class="comment">;&gt;&gt; ArityException Wrong number of args (2) passed to: user/eval12399/fn--12400   ; </span><b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>reduce</code>의 첫 번째 인수는 두 개의 인수를 받는 함수이어야 하는데, 한 개를 받는 함수가
주어져 예외를 일으킨다.</p>
</li>
<li>
<p>하지만, 에러 메시지에 나와 있는 함수명(<code>fn--12400</code>)은 식별하기 힘든 이름을
반환하고 있어 어느 익무명 함수가 에러를 일으켰는지 구분하기 힘들다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>위와 같은 경우에 각각의 무명 함수에 이름을 부여하면, 다음과 같이 좀 더 식별하기 쉬운
함수명(<code>fn-a--12408</code>)을 가진 에러 메시지가 출력된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">reduce</span> (<span class="keyword">fn</span> fn-a [<span class="keyword">num</span>] (<span class="keyword">inc</span> <span class="keyword">num</span>)) [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
(<span class="keyword">filter</span> (<span class="keyword">fn</span> fn-b [<span class="keyword">num</span>] (<span class="keyword">even?</span> <span class="keyword">num</span>)) [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
<span class="comment">;&gt;&gt; ArityException Wrong number of args (2) passed to: user/eval12407/fn-a--12408</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_함수_리터럴">2.3. 함수 리터럴: #(&#8230;&#8203;)</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>함수 리터럴 <code>#()</code>을 사용하면, <code>fn</code>을 사용하는 것보다 더 간결한 형태로 무명 함수를
생성할 수 있다. 함수 리터럴 안에서 함수의 인수는 <code>%1</code>, <code>%2</code>, <code>%3</code>, &#8230;&#8203; 형식으로 표현된다.</p>
</div>
<div class="paragraph">
<p>함수 인수 <code>%1</code>은 숫자 1을 생략하고 <code>%</code>처럼 사용할 수도 있는데, 일반적으로 다음과 같은
코딩 스타일이 권장된다.</p>
</div>
<div class="paragraph">
<p>인수가 한 개뿐인 무명 함수는 <code>%</code>를 사용하는 것이 좋다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; good</span>
#(Math/round %)

<span class="comment">;; bad</span>
#(Math/round %1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>인수가 두 개 이상인 무명 함수는 <code>%1</code>을 사용하는 것이 좋다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; good</span>
#(Math/pow %1 %2)

<span class="comment">;; bad</span>
#(Math/pow % %2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>함수 리터럴의 경우에는, <code>%&amp;</code>를 통해서 가변 인수(vararg)를 받는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(#(<span class="keyword">apply</span> <span class="keyword">max</span> %&amp;) <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)
<span class="comment">;=&gt; 3</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title"><code>fn</code>과 함수 리터럴 <code>#()</code>의 차이</div>
<div class="paragraph">
<p><code>fn</code>과 함수 리터럴 <code>#()</code>은 둘다 익명 함수를 반환한다는 공통점이 있지만 다음과 같은
차이점도 있다.</p>
</div>
<div class="paragraph">
<p>첫 번째 차이점은 <code>fn</code>은 암묵적으로 코드 블럭을 감싸는 <code>(do &#8230;&#8203;)</code>가 들어가 있어서
함수의 본체에 여러 개의 식을 나열할 수 있지만, 함수 리터럴 <code>#()</code>은 그렇지 않아서 여러
개의 식을 나열하려면 명시적으로 <code>(do &#8230;&#8203;)</code>로 감싸 주어야만 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">((<span class="keyword">fn</span> [x]
   (<span class="keyword">println</span> x)
   (<span class="keyword">*</span> x <span class="integer">2</span>))
 <span class="integer">5</span>)
<span class="comment">;&gt;&gt; 5</span>
<span class="comment">;=&gt; 10</span>

(#(<span class="keyword">do</span> (<span class="keyword">println</span> %)
      (<span class="keyword">*</span> % <span class="integer">2</span>))
 <span class="integer">5</span>)
<span class="comment">;&gt;&gt; 5</span>
<span class="comment">;=&gt; 10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>두 번째 차이점은, <code>fn</code>은 중접해 사용할 수 있지만, 함수 리터럴 <code>#()</code>은 중첩해서 사용할
수 없다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">((<span class="keyword">fn</span> [a]
  ((<span class="keyword">fn</span> [b] (<span class="keyword">*</span> a b))
   (<span class="keyword">inc</span> a)))
 <span class="integer">2</span>)
<span class="comment">;=&gt; 6</span>

<span class="comment">;; 위의 코드를 함수 리터럴을 사용해서 표현했다.</span>
((#(<span class="keyword">*</span> % %)   <span class="comment">; </span><b class="conum">(1)</b>
  (<span class="keyword">inc</span> %))
 <span class="integer">2</span>)
<span class="comment">;&gt;&gt; CompilerException java.lang.RuntimeException: Unable to resolve symbol: % in this context</span></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>첫 번째 <code>%</code> 기호는 위의 코드의 <code>a</code>를, 두 번째 <code>%</code> 기호는 위의 코드의 <code>b</code>를 염두에
두고 코드를 작성했지만, 이 <code>%</code> 기호가 내부 무명 함수의 인수인지, 외부 무명 함수의
인수인지를 구별할 방법이 달리 없기 때문에, 함수 리터럴의 중첩은 허용되지 않는다.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_주요_함수들">3. 주요 함수들</h2>
<div class="sectionbody">
<div class="paragraph">
<p>아래의 함수들 중 일부는 반환값으로 변환자(transducer)를 반환한다. 변환자에 대해서는
<a href="../Transducers/transducers.html">변환자</a> 장에서 자세히 설명할 것이므로, 변환자를
반환하는 예는 생략할 것이다.</p>
</div>
<div class="sect2">
<h3 id="_mapmapvmap_indexed">3.1. map/mapv/map-indexed</h3>
<div class="paragraph">
<p>함수형 언어에서는 다음의 자바 코드에서처럼 index를 증가시키며 반복문을 실행하는 경우가
극히 드물다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.util.Arrays</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">Sample</span> {
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="type">int</span><span class="type">[]</span> array1 = {<span class="integer">0</span>, <span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>};
        <span class="type">int</span><span class="type">[]</span> array2 = array1;

        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; array1.length; i++) {   // <b class="conum">(1)</b>
            array1[i] += <span class="integer">1</span>;                         // <b class="conum">(2)</b>
        }

        <span class="predefined-type">System</span>.out.println(<span class="predefined-type">Arrays</span>.toString(array1));   <span class="comment">// [1, 2, 3, 4, 5]</span>
        <span class="predefined-type">System</span>.out.println(<span class="predefined-type">Arrays</span>.toString(array2));   <span class="comment">// [1, 2, 3, 4, 5]</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>반복을 수행하는 부분이다.</p>
</li>
<li>
<p>실제 일을 수행하는 부분이다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>위의 코드가 지니고 있는 문제점을 지적해 보자.</p>
</div>
<div class="paragraph">
<p>첫 번째 문제점은, 반복문을 처리할 때 '반복을 수행하는 부분&#8217;과 '실제 일을 수행하는 부분&#8217;을
분리할 수 없어, '반복을 수행하는 부분&#8217;을 매번 코딩해 주어야 한다는 것이다. 이 둘을 분리할
수 있다면, '반복을 수행하는 부분&#8217;을 매번 코딩할 필요가 없어진다. 컴퓨터가 가장 잘 하는
일이 인간을 대신해 단순한 일을 반복해 처리해 주는 것인데, 정작 그런 프로그램을 코딩하고
있는 프로그래머들은 단순 반복적인 코딩을 당연히 여기고 있다는 사실은 일종의 아이러니가
아닐 수 없다. 클로저에서는 이러한 문제점을 고차 함수(HOF: Higher Order Functions)를 통해
해결한다. 고차 함수는 함수 객체를 인수로 넘기는 함수를 말한다.</p>
</div>
<div class="paragraph">
<p>두 번째 문제점은, <code>array1</code> 변수를 참조하고 있는 <code>array2</code> 변수의 값도 함께 변경되었다는
것이다. 이것이 의도한 결과라면 문제가 안되겠지만, 의도하지 않은 것이라면 버그를 초래할
가능성이 높다. 실제로 프로그래밍할 때 주의해서 프로그래밍하지 않으면, 의도하지 않은
레퍼런스의 참조로 인한 버그는 흔한 일이다. 클로저에서는 이런 문제점을 불변값(immutable
value)을 통해 해결한다.</p>
</div>
<div class="paragraph">
<p>고차 함수 중에서 가장 많이 사용되는 <code>map</code> 함수를 통해서 이를 확인해 보자.</p>
</div>
<div class="sect3">
<h4 id="_map">3.1.1. map</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">map 함수</div>
<div class="content">
<pre>(map f)       =&gt; transducer
(map f coll+) =&gt; lazy-seq

f := (fn [element] ...)</pre>
</div>
</div>
<div class="paragraph">
<p><code>map</code> 함수는 다음과 같이 수학에서 한 집합에서 다른 집합으로 바꾸는 작업을 한다. <code>f</code>는
<code>coll</code>의 각 요소에 적용된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>   X                 Y
 +----+   (f x1)   +----+
 | x1 |  -------&gt;  | y1 |
 |    |   (f x2)   |    |
 | x2 |  -------&gt;  | y2 |
 |    |   (f x3)   |    |
 | x3 |  -------&gt;  | y3 |
 |    |   (f x4)   |    |
 | x4 |  -------&gt;  | y4 |
 +----+            +----+</pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>map</code> 함수는 맵 자료형을 만드는 함수가 아닌 것에 주의한다. 요소들을 인수로 받아 맵
자료형을 만드는 함수는 <code>hash-map</code>이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">hash-map</span> <span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>)   <span class="comment">;=&gt; {:b 2, :a 1}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>참고로, <code>set</code> 함수는 집합이 아닌 컬렉션 자료형을 집합 자료형으로 변환하는 역할을
수행한다. 요소들을 인수로 받아 집합 자료형을 만드는 함수는 <code>hash-set</code>이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; 벡터를 집합으로 변환한다.</span>
(<span class="keyword">set</span> [<span class="integer">1</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])   <span class="comment">;=&gt; #{1 4 3 2 5}</span>

<span class="comment">;; 집합의 요소들을 받아 집합을 생성한다.</span>
(<span class="keyword">hash-set</span> <span class="integer">1</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>)
#{<span class="integer">1</span> <span class="integer">4</span> <span class="integer">3</span> <span class="integer">2</span> <span class="integer">5</span>}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>map</code> 함수 자체에 '반복을 수행하는 부분&#8217;이 이미 내장되어 있다. 그래서 아래의 코드에서 함수
인수로 들어가는 <code>inc</code>가 '실제 일을 수행하는 부분&#8217;만을 담당하게 된다. 고차 함수 자체가
'반복을 수행하는 부분&#8217;을 제공하고, 이 함수의 인수로 들어가는 함수 <code>inc</code>와 데이터 <code>a</code>가
'실제 수행해야 할 일&#8217;을 지정하고 있는 것이다. 고차 함수의 도입으로 인해, index를 순회하며
'반복을 수행하는 부분&#8217;를 더 이상 매번 작성할 필요가 없어진 것이다! 별 것 아닌 것 같지만,
코드에서 가능한 한 중복을 제거하는 것 자체가 프로그래밍에 상당히 중요한 요소임을
간과해서는 안된다. 한 두번 반복하는 것이야 문제될 것이 없겠지만, 프로그래머 일생에 결쳐
계속해서 반복해야 한다면 이것은 큰 문제가 아닐 수 없다. 왜 같은 일을 굳이 반복해야 하는가?
그렇게 하지 않을 수 있는 방법이 있는데도 말이다.</p>
</div>
<div class="paragraph">
<p>그리고 <code>map</code> 함수에서 <code>a</code>의 값을 사용했지만, <code>a</code>의 값은 변경되지 않았다. 따라서
<code>a</code>를 참조하고 있는 <code>b</code>의 내용도 당연히 변하지 않았다. 클로저에서는 모든 값이
immutable value이다. 그래서 <code>(map inc a)</code>를 평가해 나온 값 <code>(1 2 3 4 5)</code>는 <code>a</code>의 값
<code>[0 1 2 3 4]</code>를 변경한 것이 아니라, 새로운 값을 생성한 것이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">a</span> [<span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
(<span class="keyword">def</span> <span class="function">b</span> a)

(<span class="keyword">map</span> <span class="keyword">inc</span> a)   <span class="comment">;=&gt; (1 2 3 4 5)</span>

a             <span class="comment">;=&gt; [0 1 2 3 4]</span>
b             <span class="comment">;=&gt; [0 1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>map</code> 함수는 다음과 같이 <code>coll</code> 인수를 두 개 이상 받을 수도 있다. 이 경우에는 맨 먼저 각
컬렉션의 첫 번째 요소들을 모두 가져와 함수 <code>+</code>에 적용하고, 그 다음에는 각 컬렉션의 두
번째 요소들을 모두 가져와 함수에 적용하는 방식으로 계속 이어진다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> <span class="keyword">+</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>] [<span class="integer">100</span> <span class="integer">200</span> <span class="integer">300</span>])
<span class="comment">;=&gt; (111 222 333)</span>

<span class="comment">;; 즉, 다음을 실행한 결과와 같다.</span>
(<span class="keyword">list</span> (<span class="keyword">+</span> <span class="integer">1</span> <span class="integer">10</span> <span class="integer">100</span>) (<span class="keyword">+</span> <span class="integer">2</span> <span class="integer">20</span> <span class="integer">200</span>) (<span class="keyword">+</span> <span class="integer">3</span> <span class="integer">30</span> <span class="integer">300</span>))
<span class="comment">;=&gt; (111 222 333)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>제공되는 컬렉션의 요소 수가 다르면, 요소의 수가 가장 적은 컬렉션에 맞추어 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> <span class="keyword">+</span> [<span class="integer">1</span> <span class="integer">2</span>] [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>] [<span class="integer">100</span> <span class="integer">200</span> <span class="integer">300</span>])
<span class="comment">;=&gt; (111 222)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>다음과 같은 코드는 예외가 발생하는데, <code>inc</code> 함수는 인수를 한 개만 받는 함수이기
때문이다. 즉, <code>map</code> 함수에 제공되는 컬렉션의 개수가 세 개이면, 세 개의 인수를 받을 수 있는
함수가 <code>map</code> 함수의 첫 번째 인수 자리에 와야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> <span class="keyword">inc</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>] [<span class="integer">100</span> <span class="integer">200</span> <span class="integer">300</span>])
<span class="comment">;&gt;&gt; ArityException Wrong number of args (3) passed to: core/inc</span>

 <span class="comment">;; 즉, 다음을 실행한 결과와 같기 때문에 예외가 발생한다.</span>
(<span class="keyword">list</span> (<span class="keyword">inc</span> <span class="integer">1</span> <span class="integer">10</span> <span class="integer">100</span>) (<span class="keyword">inc</span> <span class="integer">2</span> <span class="integer">20</span> <span class="integer">200</span>) (<span class="keyword">inc</span> <span class="integer">3</span> <span class="integer">30</span> <span class="integer">300</span>))
<span class="comment">;&gt;&gt; ArityException: Wrong number of args (3) passed to: core/inc</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>마지막으로 초보자들이 <code>map</code> 함수를 사용할 때 종종 겪는 실수를 한 가지 언급하겠다. 그것은
바로 <code>map</code>의 첫 번째 함수 인수 자리에 부수 효과(side effects)를 일으키는 함수를 사용하는
데서 비롯되는 실수이다. 이것은 lazy-seq를 반환하는 모든 클로저 함수에 해당하는
이야기이기도 하다.</p>
</div>
<div class="paragraph">
<p>다음의 예제를 실행하면, 기대와는 달리 숫자 <code>1 2 3</code>이 화면에 출력되지 않는다. 그 이유는
<code>map</code> 함수가 반환한 lazy-seq가 실현(realized)될 기회를 갖지 못하기 때문이다. lazy-seq는
실현될 기회를 갖지 못하면 영원히 실현되지 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  <span class="comment">;; map 함수의 실행 결과로 lazy-seq가 반환되지만, 쓰여지지 않은채 그냥 버려진다.</span>
  <span class="comment">;; 즉, 실현될 기회를 갖지 못하게 된다. 따라서 println 함수가 호출될 기회기 없다.</span>
  (<span class="keyword">map</span> <span class="keyword">println</span> <span class="keyword">num</span>)
  (<span class="keyword">conj</span> <span class="keyword">num</span> <span class="integer">4</span>))
<span class="comment">;=&gt; [1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>반면에 아래의 코드에서는, <code>map</code> 함수가 마찬가지로 laz-seq를 반환하지만, 또한 <code>let</code>의
반환값으로도 반환되고 있다. 이후 이 반환값을 REPL(Read-Eval-Print-Loop)에서 출력하는
과정에서 실현될 기회를 갖게 되어, 숫자 <code>1 2 3</code>이 화면에 출력된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (<span class="keyword">map</span> <span class="keyword">println</span> <span class="keyword">num</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; (nil nil nil)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>따라서 부수 효과가 주목적이라면, <code>map</code> 함수가 아니라 부수 효과를 위해 준비된 <code>doseq</code>을
사용해야 한다. 아울러 아래의 코드에서 <code>doseq</code>이 <code>(2 4 6)</code>의 결과를 반환할 것이라
예상하겠지만,<code>doseq</code>은 마지막 반환 결과를 무시하고, 무조건 <code>nil</code>을 반환한다는 점에
주목하자. 한 마디로 <code>doseq</code>은 오로지 부수 효과만을 수행할 목적으로 마련된 매크로라고
보면 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">doseq</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (<span class="keyword">println</span> <span class="keyword">num</span>)
  (<span class="keyword">*</span> <span class="keyword">num</span> <span class="integer">2</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>부득이하게 <code>map</code> 함수를 부수 효과를 적용하는데 사용해야만 하는 상황이라면, lazy-seq를 강제로
실현해 주는 <code>dorun</code>을 이용하는 방법도 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (<span class="keyword">dorun</span> (<span class="keyword">map</span> <span class="keyword">println</span> <span class="keyword">num</span>))
  (<span class="keyword">conj</span> <span class="keyword">num</span> <span class="integer">4</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; [1 2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>그리고 클로저 1.7.0에서 새로 도입된 <code>run!</code> 함수를 사용할 수도 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (run! <span class="keyword">println</span> <span class="keyword">num</span>)
  (<span class="keyword">conj</span> <span class="keyword">num</span> <span class="integer">4</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; [1 2 3 4]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapv">3.1.2. mapv</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">mapv 함수</div>
<div class="content">
<pre>(mapv f coll+) =&gt; vector</pre>
</div>
</div>
<div class="paragraph">
<p><code>mapv</code> 함수는 lazy-seq를 반환하는 <code>map</code> 함수와는 달리 벡터 자료형을 반환한다. 클로저에서
지연 평가(lazy evaluation)가 일어나는 유일한 자료형은 lazy-seq이다. 다시 말해, lazy-seq
자료형을 제외한 모든 자료형은 즉시 평가(eager evaluation)가 일어난다. 따라서 <code>mapv</code> 함수는
벡터 자료형을 반환하므로 지연 평가가 일어나지 않고 즉시 평가(eager evaluation)가 일어나게
되어, 함수 인수 <code>f</code> 자리에 부수 효과가 일어나는 함수가 올 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">let</span> [<span class="keyword">num</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]]
  (mapv <span class="keyword">println</span> <span class="keyword">num</span>)
  (<span class="keyword">conj</span> <span class="keyword">num</span> <span class="integer">4</span>))
<span class="comment">;&gt;&gt; 1</span>
<span class="comment">;&gt;&gt; 2</span>
<span class="comment">;&gt;&gt; 3</span>
<span class="comment">;=&gt; [1 2 3 4]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_map_indexed">3.1.3. map-indexed</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">map-indexed 함수</div>
<div class="content">
<pre>(map-indexed f)       =&gt; transducer
(map-indexed f coll+) =&gt; lazy-seq

f := (fn [index element] ...)</pre>
</div>
</div>
<div class="paragraph">
<p><code>map-indexed</code>는 함수 인수인 <code>f</code>가 <code>[index item]</code> 함수의 두 개의 인수를 받게 된다는
점을 제외하고는 <code>map</code> 함수와 동일하다. 이 함수는 현재 처리하고 있는 <code>coll</code>의 요소가
<code>coll</code>의 몇 번째 항목인지 알고 싶을 때 사용하면 유용하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(map-indexed (<span class="keyword">fn</span> [index item] [index item]) <span class="string"><span class="delimiter">&quot;</span><span class="content">foobar</span><span class="delimiter">&quot;</span></span>)
<span class="comment">;=&gt; ([0 \f] [1 \o] [2 \o] [3 \b] [4 \a] [5 \r])</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_filterfiltervremove">3.2. filter/filterv/remove</h3>
<div class="sect3">
<h4 id="_filter">3.2.1. filter</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">filter 함수</div>
<div class="content">
<pre>(filter pred)       =&gt; transducer
(filter pred coll?) =&gt; lazy-seq</pre>
</div>
</div>
<div class="paragraph">
<p><code>filter</code> 함수는 <code>coll</code>의 요소 <code>element</code>에 대해 <code>(pred element)</code>가 논리적 참인
<code>element</code>들로 이루어진 lazy-seq를 리턴한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>   X                               Y
 +----+    (pred x1) =&gt; true     +----+
 | x1 | -----------------------&gt; | x1 |
 |    |    (pred x2) =&gt; false    |    |
 | x2 | -----------------------&gt; |    |
 |    |    (pred x3) =&gt; true     |    |
 | x3 | -----------------------&gt; | x3 |
 |    |    (pred x4) =&gt; false    |    |
 | x4 | -----------------------&gt; |    |
 +----+                          +----+</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">filter</span> <span class="keyword">even?</span> (<span class="keyword">range</span> <span class="integer">10</span>))
<span class="comment">;=&gt; (0 2 4 6 8)</span>

(<span class="keyword">filter</span> <span class="keyword">identity</span> [<span class="predefined-constant">false</span> <span class="predefined-constant">nil</span> <span class="integer">10</span> <span class="symbol">:a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]])
<span class="comment">;=&gt; (10 :a &quot;hello&quot; [1 2 3])</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_filterv">3.2.2. filterv</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre>(filterv pred coll) =&gt; vector</pre>
</div>
</div>
<div class="paragraph">
<p><code>filterv</code> 함수는 <code>map</code>과 <code>mapv</code> 함수의 관계와 같다. 즉, lazy-seq를 반환하는 <code>filter</code>
함수와는 달리, 벡터를 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(filterv <span class="keyword">even?</span> (<span class="keyword">range</span> <span class="integer">10</span>))
<span class="comment">;=&gt; [0 2 4 6 8]</span>

(filterv <span class="keyword">identity</span> [<span class="predefined-constant">false</span> <span class="predefined-constant">nil</span> <span class="integer">10</span> <span class="symbol">:a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]])
<span class="comment">;=&gt; [10 :a &quot;hello&quot; [1 2 3]]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_remove">3.2.3. remove</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre>(remove pred)       =&gt; transducer
(remove pred coll) =&gt; lazy-seq</pre>
</div>
</div>
<div class="paragraph">
<p><code>remove</code>는 <code>filter</code>와 정반대이다. 즉, <code>coll</code>의 요소 <code>element</code>에 대해 <code>(pred
element)</code>가 논리적 참인 <code>element</code>를 모두 제거한 요소들로 이루어진 lazy-seq를 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">remove</span> <span class="keyword">even?</span> (<span class="keyword">range</span> <span class="integer">10</span>))
<span class="comment">;=&gt; (1 3 5 7 9)</span>

(<span class="keyword">remove</span> <span class="keyword">identity</span> [<span class="predefined-constant">false</span> <span class="predefined-constant">nil</span> <span class="integer">10</span> <span class="symbol">:a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">hello</span><span class="delimiter">&quot;</span></span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]])
<span class="comment">;=&gt; (false nil)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reducereduce_kvreductions">3.3. reduce/reduce-kv/reductions</h3>
<div class="paragraph">
<p></p>
</div>
<div class="sect3">
<h4 id="_reduce">3.3.1. reduce</h4>
<div class="listingblock">
<div class="title">reduce 함수</div>
<div class="content">
<pre>(reduce f init? coll)

f := (fn [acc element] ...)
     이 함수의 첫 번쨰 인수인 acc에 누적(accumulation)된 값이 담기고,
     두 번째 인수 element에 coll의 각 요소가 담긴다.
init := 초기값</pre>
</div>
</div>
<div class="paragraph">
<p><code>reduce</code> 함수는 약간 복잡하기는 하지만, 잘만 사용하면 왠만한 일은 거의 처리할 수 있을
정로로 매우 강력한 함수이므로, 잘 이해해 두도록 한다.</p>
</div>
<div class="paragraph">
<p>먼저 그림을 통해 이해해 보자. 만약 이 함수가 <code>(reduce f init [x1 x2 x3 &#8230;&#8203; xn])</code>과 같이
호출되었다고 가정하면, 계산은 다음과 같이 진행된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(f init x1)    =&gt; acc1  ; <b class="conum">(1)</b>
    |--------------|
    v
(f acc1 x2)    =&gt; acc2  ; <b class="conum">(2)</b>
    |--------------|
    v
(f acc2 x3)    =&gt; acc3
    |--------------|
    v
(f accn xn)    =&gt; acc (최종값)   ; <b class="conum">(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>초기값 <code>init</code>과 첫 번째 요소 <code>x1</code>을 함수 <code>f</code>에 적용한다.</p>
</li>
<li>
<p>위에서 얻은 결과값 <code>acc1</code>과, 두 번째 요소 <code>x2</code>를 함수 <code>f</code>에 다시 적용한다.</p>
</li>
<li>
<p>이런 식으로 계산된 최종값 <code>acc</code>가 <code>reduce</code> 함수의 반환값으로 리턴된다.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>실제 예를 통해 구체적으로 살펴 보면, <code>(reduce + 10 [1 2 3 4 5])</code>가 계산되는 과정은
다음과 같다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(+ 10 1)   =&gt; 11
   |----------|
   v
(+ 11 2)   =&gt; 13
   |----------|
   v
(+ 13 3)   =&gt; 16
   |----------|
   v
(+ 16 4)   =&gt; 20
   |----------|
   v
(+ 20 5)   =&gt; 25 (최종값)</pre>
</div>
</div>
<div class="paragraph">
<p>만약 <code>(reduce f [x1 x2 x3 &#8230;&#8203; xn])</code>에서처럼 <code>init</code>이 주어지지 않으면, 계산은 다음과
같이 진행된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(f x1 x2)       =&gt; acc1
    |---------------|
    v
(f acc1 x3)     =&gt; acc2
    |---------------|
    v
(f acc2 x4)     =&gt; acc3
    |---------------|
    v
(f accn xn)     =&gt; acc (최종값)</pre>
</div>
</div>
<div class="paragraph">
<p>다시 실제 예를 통해 구체적으로 살펴 보면, <code>(reduce + [1 2 3 4 5])</code>가 계산되는 과정은
다음과 같다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(+ 1 2)    =&gt; 3
   |----------|
   v
(+ 3 3)    =&gt; 6
   |----------|
   v
(+ 6 4)    =&gt; 10
   |----------|
   v
(+ 10 5)   =&gt; 15 (최종값)</pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">Caution</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>reduce</code> 함수를 사용할 때 한 가지 주의해야 할 점은, 이 함수는 lazy-seq를 반환하지 않는다는
것이다. 따라서 메모리 사용량이 아주 많은 연산을 수행할 떄는 다음처럼 문제가 발생할 수
있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">reduce</span> <span class="keyword">+</span> (<span class="keyword">range</span>))
<span class="comment">;&gt;&gt; ArithmeticException integer overflow</span>

(<span class="keyword">reduce</span> <span class="keyword">conj</span> [] (<span class="keyword">range</span>))
<span class="comment">;&gt;&gt; Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_reduce_kv">3.3.2. reduce-kv</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">reduce-kv 함수</div>
<div class="content">
<pre>(reduce-kv f init coll)

f := (fn [acc key value] ...)
     이 함수의 첫 번쨰 인수인 acc에 누적(accumulation)된 값이 담기고, 두 번째 인수에
     coll의 각 요소의 key가, 세 번쨰 인수에 각 요소의 value가 담긴다.
init := 초기값</pre>
</div>
</div>
<div class="paragraph">
<p><code>reduce-kv</code> 함수는 <code>reduce</code>와 유사하지만, 함수 인수 <code>f</code>가 받아들일 인수가 <code>[acc
element]</code>의 2개가 아니라 <code>[acc key value]</code>의 3개이다. 그리고 <code>init</code> 값이 반드시
제공되어야 하고, <code>coll</code> 자리에는 맵이나 벡터가 와야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(reduce-kv (<span class="keyword">fn</span> [acc k v]
             (<span class="keyword">assoc</span> acc k (<span class="keyword">inc</span> v)))
           {}
           {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span> <span class="symbol">:d</span> <span class="integer">4</span>})
<span class="comment">;=&gt; {:a 2, :b 3, :c 4, :d 5}</span>

<span class="comment">;; 벡터도 key가 벡터의 인덱스이고, value가 벡터의 각 요소인 맵이다.</span>
(reduce-kv (<span class="keyword">fn</span> [acc k v]
             (<span class="keyword">assoc</span> acc k (<span class="keyword">inc</span> v)))
           {}
           [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>])
<span class="comment">;=&gt; {0 11, 1 21, 2 31}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reductions">3.3.3. reductions</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">reductions 함수</div>
<div class="content">
<pre>(reductions f init? coll) =&gt; lazy-seq</pre>
</div>
</div>
<div class="paragraph">
<p>이 함수는 <code>reduce</code> 함수의 '초기값&#8217;과 '매 단계별 누적값들&#8217;을 모두 담은 lazy-seq를
반환한다. <code>reduce</code> 함수의 누적값의 진행 상황을 알아보고 싶을 때 유용하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(reductions <span class="keyword">+</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
<span class="comment">;=&gt; (1 3 6 10)</span>

(reductions <span class="keyword">+</span> <span class="integer">10</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
<span class="comment">;=&gt; (10 11 13 16 20)</span>

(reductions <span class="keyword">conj</span> [] [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
<span class="comment">;=&gt; ([] [1] [1 2] [1 2 3] [1 2 3 4])</span>

(reductions <span class="keyword">conj</span> () [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>])
<span class="comment">;=&gt; (() (1) (2 1) (3 2 1) (4 3 2 1))</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apply">3.4. apply</h3>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">apply 함수</div>
<div class="content">
<pre>(apply f element* coll)</pre>
</div>
</div>
<div class="paragraph">
<p><code>apply</code> 함수는 <code>element</code>가 제공되지 않을 경우에는 <code>coll</code>을 함수 <code>f</code>에 단순히
적용(apply)한다. `element`들이 제공될 경우에는 <code>element</code>와 <code>coll</code>을 리스트로 한데 묶은
후, 함수 <code>f</code>를 적용한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">apply</span> <span class="keyword">min</span> [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>])
<span class="comment">;=&gt; 10</span>

<span class="comment">;; 위는 아래를 실행한 것과 같다.</span>
(<span class="keyword">min</span> <span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>)
<span class="comment">;=&gt; 10</span>

(<span class="keyword">apply</span> <span class="keyword">min</span> <span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span> [<span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>])
<span class="comment">;=&gt; 0</span>

<span class="comment">;; 위는 아래를 실행한 것과 같다.</span>
(<span class="keyword">min</span> <span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">10</span> <span class="integer">20</span> <span class="integer">30</span>)
<span class="comment">;=&gt; 0</span>

<span class="comment">;; min 함수는 인수가 전혀 없으면 예외가 발생한다.</span>
(<span class="keyword">min</span>)
<span class="comment">;&gt;&gt; ArityException Wrong number of args (0) passed to: core/min</span>

<span class="comment">;; 이번에는 디폴트 값으로 0을 제공하고 있어서 예외가 발생하지 않는다.</span>
(<span class="keyword">apply</span> <span class="keyword">min</span> <span class="integer">0</span> [])
<span class="comment">;=&gt; 0</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">apply와 reduce 함수의 차이</div>
<div class="paragraph">
<p>프로그램을 짜다 보면, <code>apply</code>와 <code>reduce</code> 함수를 언제 사용해야 할지 잘 판단이 서지 않는
경우가 종종 있다. 그래서 여기서는 그 차이점을 알아보도록 하겠다.</p>
</div>
<div class="paragraph">
<p>예를 들어, 아래의 코드를 보면, <code>apply</code>와 <code>reduce</code> 함수가 동일한 결과값을 반환하고
있다. 계산 결과는 같게 나오지만, 계산 과정은 같지 않다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">apply</span> <span class="keyword">+</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])    <span class="comment">; =&gt; 15</span>
(<span class="keyword">reduce</span> <span class="keyword">+</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])   <span class="comment">; =&gt; 15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>그렇다면 이 두 함수의 차이는 무엇인가? 그 차이를 알아보기 위해 먼저 <code>add</code>라는 함수를
다음과 같이 정의하고 테스트를 진행해 보자.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">add</span> [a b]
  (<span class="keyword">+</span> a b))

(<span class="keyword">apply</span> add [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])
<span class="comment">;&gt;&gt; clojure.lang.ArityException: Wrong number of args</span>

(<span class="keyword">reduce</span> add [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])
<span class="comment">; =&gt; 15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>apply</code> 함수의 경우에만 ArrityException이 발생했다. 그 이유는 <code>add</code> 함수가 정확히 2개의
인수만을 받아들이도록 정의되어 있기 때문이다. 다시 말해, <code>(apply add [1 2 3 4 5])</code>로
호출하면, <code>(add 1 2 3 4 5)</code> 식으로 실행되므로 당연히 에러가 발생할 수밖에 없다.</p>
</div>
<div class="paragraph">
<p>이에 반해, <code>+</code> 함수는 인수가 <code>[a b &amp; more]</code> 식으로 정의되어 있다. 다시 말해, <code>+</code> 함수는
원래 다인수 함수로 정의되어 있어서, <code>(apply + [1 2 3 4 5])</code> 식으로 호출하면 <code>(+ 1 2 3 4
5)</code> 식으로 실행되므로, 결과적으로 에러가 발생하지 않는다.</p>
</div>
<div class="paragraph">
<p>반면에, <code>(reduce add [1 2 3 4 5])</code>는 <code>(add (add (add (add 1 2) 3) 4) 5)</code> 식으로
실행되므로, 에러가 발생하지 않는 것이다.</p>
</div>
<div class="paragraph">
<p>따라서 '3개 이상의 인수를 받아들이는' 함수를 호출 하는 경우에는 <code>apply</code> 함수를 사용할 수
있지만, '2개의 인수만을 받아들이는' 함수를 호출하는 경우에는 <code>reduce</code> 함수를 사용해야
한다.</p>
</div>
<div class="paragraph">
<p>조금 설명을 보충하자면, <code>apply</code>는 두 번째 인수로 나온 컬렉션의 괄호를 풀어 헤쳐, 첫 번째
인수로 주어진 함수에 일괄적으로 적용하는 함수로 이해하면 좋다. 이에 반해 <code>reduce</code>는
일종의 재귀 함수로 이해하면 된다. 여기서 <code>+</code> 함수의 첫 번째 인수는 누적값을 계속 쌓아
나가는 용도로, 두 번째 인수는 새로운 요소의 값을 받아들이는 용도로 사용된다.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keepkeep_indexed">3.5. keep/keep-indexed</h3>
<div class="sect3">
<h4 id="_keep">3.5.1. keep</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">keep 함수</div>
<div class="content">
<pre>(keep f)      =&gt; transdducer
(keep f coll) =&gt; lazy-seq

f := (fn [element] ...)</pre>
</div>
</div>
<div class="paragraph">
<p><code>keep</code> 함수는 <code>coll</code>의 각 <code>element</code>에 대해 <code>(f element)</code>을 수행한 후, 그 반환값이
<code>nil</code>이 아닌 값들만을 담은 lazy-seq를 반환한다.</p>
</div>
<div class="paragraph">
<p>예를 들어, 컬렉션 <code>[0 1 2 3 4 5]</code>의 값들 중에서 홀수들만을 취해 그 수를 제곱하고 싶을 떄
는 <code>keep</code> 함수를 이용해 다음과 같이 하면 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(keep (<span class="keyword">fn</span> [<span class="keyword">num</span>]
        (<span class="keyword">when</span> (<span class="keyword">odd?</span> <span class="keyword">num</span>) (<span class="keyword">*</span> <span class="keyword">num</span> <span class="keyword">num</span>)))
      [<span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])
<span class="comment">;=&gt; (1 9 25)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>이런 경우 <code>map</code> 함수를 이용하면 다음과 같은 원하지 않는 결과도 반환하게 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> (<span class="keyword">fn</span> [<span class="keyword">num</span>]
        (<span class="keyword">when</span> (<span class="keyword">odd?</span> <span class="keyword">num</span>) (<span class="keyword">*</span> <span class="keyword">num</span> <span class="keyword">num</span>)))
     [<span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])
<span class="comment">;=&gt; (nil 1 nil 9 nil 25)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>결론적으로 말하자면, <code>map</code> 함수는 첫 번째 인수인 함수 <code>f</code>가 어떤 값을 반환하느냐에 상관
없이 무조건 입력값에 해당하는 개수만큼의 결과값을 반환하지만, <code>keep</code> 함수는 입력값들
중에서 처리를 원하지 않는 값들의 경우에는 일부러 nil을 반환하는 것을 통해, 처리를 원치
않는 값들을 결과값에 포함되지 않도록 할 수 있다.</p>
</div>
</div>
<div class="sect3">
<h4 id="_keep_indexed">3.5.2. keep-indexed</h4>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="title">keep-indexed 함수</div>
<div class="content">
<pre>(keep-indexed f)      =&gt; transdducer
(keep-indexed f coll) =&gt; lazy-seq

f := (fn [index element] ...)</pre>
</div>
</div>
<div class="paragraph">
<p><code>keep-indexed</code>는 함수 인수 <code>f</code>가 <code>coll</code>의 <code>index</code>와 <code>element</code> 두 개의 인수를
받는다는 점을 제외하고는 <code>keep</code> 함수와 동일하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(keep-indexed (<span class="keyword">fn</span> [index <span class="keyword">num</span>]
                (<span class="keyword">if</span> (<span class="keyword">pos?</span> <span class="keyword">num</span>) index))
              [<span class="integer">-9</span> <span class="integer">0</span> <span class="integer">29</span> <span class="integer">-7</span> <span class="integer">45</span> <span class="integer">3</span> <span class="integer">-8</span>])
<span class="comment">;=&gt; (2 4 5)</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. <code>#'</code>는 var의 reader 매크로이다.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. 일반적으로 anonymous function을 흔히들 익명 함수라고 번역하고 있는데, '익명&#8217;은 이미 있는 이름을 '숨긴다&#8217;는 의미이기 때문에, '무명&#8217;으로 번역하는 것이 옳다고 본다.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. 실제로는 훨씬 복잡하게 정의되어 있지만, 이곳에서는 최대한으로 단순화했다.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-12-14 02:45:19 UTC
</div>
</div>
</body>
</html>