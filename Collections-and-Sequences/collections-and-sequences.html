<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>컬렉션과 시퀀스</title>
<link rel="stylesheet" href="../my-asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../coderay-asciidoctor.css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71804757-1', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>컬렉션과 시퀀스</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_컬렉션">1. 컬렉션</a>
<ul class="sectlevel2">
<li><a href="#_컬렉션_리터럴literals">1.1. 컬렉션 리터럴(Literals)</a></li>
<li><a href="#_컬렉션의_생성">1.2. 컬렉션의 생성</a></li>
<li><a href="#_seq">1.3. seq</a></li>
<li><a href="#_컬렉션에_요소_추가삭제">1.4. 컬렉션에 요소 추가/삭제</a>
<ul class="sectlevel3">
<li><a href="#_cons">1.4.1. cons</a></li>
<li><a href="#_conj">1.4.2. conj</a></li>
<li><a href="#_disj">1.4.3. disj</a></li>
<li><a href="#_assoc">1.4.4. assoc</a></li>
<li><a href="#_dissoc">1.4.5. dissoc</a></li>
<li><a href="#_assoc_in">1.4.6. assoc-in</a></li>
</ul>
</li>
<li><a href="#_컬렉션에서_요소_참조">1.5. 컬렉션에서 요소 참조</a>
<ul class="sectlevel3">
<li><a href="#_nth">1.5.1. nth</a></li>
<li><a href="#_get">1.5.2. get</a></li>
<li><a href="#_get_in">1.5.3. get-in</a></li>
<li><a href="#_find">1.5.4. find</a></li>
<li><a href="#_contains">1.5.5. contains?</a></li>
<li><a href="#_keys와_vals">1.5.6. keys와 vals</a></li>
<li><a href="#_key와_val">1.5.7. key와 val</a></li>
<li><a href="#_직접_참조">1.5.8. 직접 참조</a></li>
<li><a href="#_고차함수에서_직접_참조_사용하기">1.5.9. 고차함수에서 직접 참조 사용하기</a></li>
</ul>
</li>
<li><a href="#_컬렉션_진위_함수predicates">1.6. 컬렉션 진위 함수(predicates)</a></li>
<li><a href="#_스택_큐_트리">1.7. 스택 / 큐 / 트리</a>
<ul class="sectlevel3">
<li><a href="#_스택">1.7.1. 스택</a></li>
<li><a href="#_큐">1.7.2. 큐</a></li>
<li><a href="#_트리">1.7.3. 트리</a>
<ul class="sectlevel4">
<li><a href="#_지퍼zipper">지퍼(Zipper)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_정렬">1.8. 정렬</a>
<ul class="sectlevel3">
<li><a href="#_sort와_sort_by">1.8.1. sort와 sort-by</a></li>
<li><a href="#_sorted_map와_sorted_set">1.8.2. sorted-map와 sorted-set</a></li>
<li><a href="#_sorted_map_by와_sorted_set_by">1.8.3. sorted-map-by와 sorted-set-by</a></li>
<li><a href="#_reverse_rseq">1.8.4. reverse / rseq</a></li>
<li><a href="#_subseq_rsubseq">1.8.5. subseq / rsubseq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
10개의 데이타 구조에 동작하는 10개의 함수보다는 한 개의 데이타 구조에 동작하는 100개의 함수가 더 좋다.
</blockquote>
<div class="attribution">
&#8212; 앨런 펄리스(Alan J. Perlis)<br>
<cite>프로그래밍 경구</cite>
</div>
</div>
<div class="paragraph">
<p>지난 장에서는 단순 자료형을 설명하였다. 이번 장에서는 복합 자료형 혹은 컬렉션을 설명한다.</p>
</div>
<div class="paragraph">
<p>위 경구는 클로저에서 컬렉션, 특히 자료구조(Data Structures)의 설계적 측면을 가장 잘 표현한 것이다. 실제로 클로저는 단일한 추상적 자료구조와 이것을 다루는 100여 개의 코어 함수를 제공하는데, 이것은 클로저의 뼈대를 이루는 핵심적 토대로서, 그 밖에 다른 모든 언어적 기능들이 기본적으로 이러한 토대에 기반한다.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_컬렉션">1. 컬렉션</h2>
<div class="sectionbody">
<div class="paragraph">
<p>컬렉션은 여러 데이터를 하나의 덩어리로 묶어서 다루기 위한 것이다. 클로저는 컬렉션으로 사용할 수 있는 여러가지 자료구조(Data Structures)를 제공하는데 다음과 같은 특징을 갖는다.</p>
</div>
<div class="ulist">
<div class="title">클로저 컬렉션의 특징</div>
<ul>
<li>
<p>불변값이다(Immutable)</p>
</li>
<li>
<p>존속적이다(Persistent)</p>
</li>
<li>
<p>구조의 공유(Structural Sharing)</p>
</li>
<li>
<p>동등 비교는 값으로만 한다.</p>
</li>
<li>
<p>hash 값을 제공한다.</p>
</li>
<li>
<p>스레드 안전하다(thread-safe)</p>
</li>
<li>
<p>추상(Abstraction)으로 표현된다.</p>
</li>
<li>
<p>java.lang.Iterable을 구현한다.</p>
</li>
<li>
<p>java.util.Collection의 일부 read-only 부분을 구현한다.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>클로저 컬렉션의 이러한 특성으로 인해 클로저는 다른 리스프(LISP)언어와는 구별된다.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> 또한 클로저 컬렉션은 클로저가 함수형 프로그래밍 언어로서의 효율적이고 효과적으로 동작하는데 았어 매우 중요한 역할을 한다. 자료구조의 이러한 특성을 잘 아는 것은 그것을 잘 사용하는 것 만큼이나 중요하다. 앞으로 본 장을 통해서 위 특성들에 대해 자세히 살펴볼 것이다.</p>
</div>
<div class="paragraph">
<p>컬렉션으로서 데이터를 어떤 방식으로 묶느냐에 따라 클로저는 다음 4개의 컬레션을 제공한다.</p>
</div>
<div class="dlist">
<div class="title">클로저 컬렉션</div>
<dl>
<dt class="hdlist1">리스트</dt>
<dd>
<p>가장 단순한 컬렉션으로 순차 접근이 가능하다. 단일 연결 리스트로 되어 있다.</p>
</dd>
<dt class="hdlist1">벡터</dt>
<dd>
<p>임의 접근이 가능하다. 다른 언어에서의 배열 정도에 해당한다.</p>
</dd>
<dt class="hdlist1">맵</dt>
<dd>
<p>키-값 쌍으로 구성된다. 파이썬의 dictionary, 루비의 Hash에 해당한다.</p>
</dd>
<dt class="hdlist1">집합</dt>
<dd>
<p>중복되지 않는 요소를 갖는다.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>클로저에서 제공하는 컬렉션은 리스트, 벡터, 맵, 집합이다. 그밖에 자바에서 제공하는 컬렉션도 있다. 또한 문자열도 컬렉션이다. 이 책에서는 특별한 언급이 없으면 컬렉션은 클로저의 컬렉션을 의미하한다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_컬렉션_리터럴literals">1.1. 컬렉션 리터럴(Literals)</h3>
<div class="paragraph">
<p>컬렉션 리터럴은 컬렉션을 어떻게 표기하는지를 나타내는 것이다. 다음은 리스트, 벡터, 맵, 집합의 리터럴 표기를 보여준다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;;; 컬렉션은 여러가지 자료형의 단순값을 요소로 취할 수 있다.</span>

'(<span class="integer">1</span> <span class="float">1.0</span> <span class="symbol">:a</span> <span class="char">\a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>)  <span class="comment">; 리스트 리터럴 </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; (1 1.0 :a \a &quot;a&quot;)</span>

[<span class="integer">1</span> <span class="float">1.0</span> <span class="symbol">:a</span> <span class="char">\a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>]   <span class="comment">; 벡터 리터럴   </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="comment">;=&gt; [1 1.0 :a \a &quot;a&quot;]</span>

{<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>}    <span class="comment">; 맵 리터럴     </span><i class="conum" data-value="3"></i><b>(3)</b>
<span class="comment">;=&gt; {:a 1, :c 3, :b 2}  </span><i class="conum" data-value="4"></i><b>(4)</b> <i class="conum" data-value="5"></i><b>(5)</b>

#{<span class="integer">1</span> <span class="float">1.0</span> <span class="symbol">:a</span> <span class="char">\a</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>}  <span class="comment">; 집합 리터럴   </span><i class="conum" data-value="6"></i><b>(6)</b>
<span class="comment">;=&gt; #{1.0 1 :a \a &quot;a&quot;} </span><i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>리스트 : 괄호 ()로 묶고, 앞에 인용 기호를 붙인다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>벡터  : 대괄호 []로 묶는다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>맵    : 중괄호 {)로 묶는다.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>리스트와 벡터와는 달리 맵은 요소 간에 순서가 없다. 그래서 정의했을 때의 순서가 보장되지 않는다.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>쉼표(,)는 스페이스로 취급되기 때문에, 있으나 없으나 상관없다.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>집합  : #이 앞에 붙은 중괄호 #{}로 묶는다.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>집합도 맵과 마찬가지로 요소 간에 순서가 없다.</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">리스트는 특별하다</div>
<div class="paragraph">
<p>클로저에서 리스트는 특별하다. 리스트는 데이타를 묶는 컬렉션으로서의 역할도 있지만, 다른 리스프(LISP)언어에서처럼 함수를 호출하는 역할도 있다. 리스트가 함수를 호출하는 역할은 하지 않고, 다만 데이타를 묶는 역할만 하도록 하기 위해 인용 기호(')를 괄호 앞에 붙인다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; 첫 요소인 +를 함수로서 호출한다.</span>
(<span class="keyword">+</span> <span class="integer">1</span> <span class="integer">2</span>)
<span class="comment">;=&gt; 3</span>

<span class="comment">;; 첫 요소인 1을 함수로서 호출한다. 하지만 1은 함수가 아니라서 예외가 발생한다.</span>
(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)
<span class="comment">;&gt;&gt; ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn</span>

<span class="comment">;; 인용부호(')를 붙이면 리스트는 첫 요소를 함수로 호출하는 역할을 하지 않는다.</span>
<span class="comment">;; 단지 리스트 자료형의 역할만 한다.</span>
'(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)
<span class="comment">;=&gt; (1 2 3)</span>

<span class="comment">;; +를 함수로서 호출하지 않는다. +는 리스트의 첫 요소일 뿐이다.</span>
'(<span class="keyword">+</span> <span class="integer">1</span> <span class="integer">2</span>)
<span class="comment">;=&gt; (+ 1 2)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>하지만 데이타가 없는 빈 리스트는 함수로서 취급할 요소가 없으므로 인용 기호(')가 없어도 예외가 발생하지 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">=</span> () '())
<span class="comment">;=&gt; true</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>컬렉션의 요소로 컬렉션이 올 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">'((<span class="integer">1</span>) [<span class="integer">1</span>] {<span class="symbol">:a</span> <span class="integer">1</span>} #{<span class="integer">1</span>})  <span class="comment">; 리스트 안에 리스트, 벡터, 맵, 집합이 있다. </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; ((1) [1] #{1} {:a 1})</span>

['(<span class="integer">1</span>) [<span class="integer">1</span>] {<span class="symbol">:a</span> <span class="integer">1</span>} #{<span class="integer">1</span>}]  <span class="comment">; 벡터 안에 리스트, 벡터, 집합, 맵이 있다.</span>
<span class="comment">;=&gt; [(1) [1] #{1} {:a 1}]</span>

{'(<span class="integer">1</span>) [<span class="integer">1</span>] #{<span class="integer">1</span>} {<span class="symbol">:a</span> <span class="integer">1</span>}}  <span class="comment">; 맵 안에 리스트, 벡터, 맵, 집합이 있다.</span>
<span class="comment">;=&gt; {(1) [1] {:a 1} #{1}} </span><i class="conum" data-value="2"></i><b>(2)</b>

#{'(<span class="integer">1</span>) [<span class="integer">1</span>] {<span class="symbol">:a</span> <span class="integer">1</span>} #{<span class="integer">1</span>}} <span class="comment">; 집합 안에 리스트, 벡터, 맵, 집합이 있다.</span>
<span class="comment">;=&gt; #{[1] #{1} {:a 1}}  </span><i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>내포된 리스트에는 인용 부호(')를 붙이지 않아도 된다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>맵의 키로 컬렉션이 사용될 수 있다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>(= '(1) [1])</code>이기 때문에 <code>[1]</code>만 남는다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>맵의 경우에는 같은 키가 중복되는 것을 허용하지 않는다. 같은 키가 있으면 예외가 발생한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; 키 :a가 중복되어 예외가 발생한다.</span>
{<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:a</span> <span class="integer">2</span>}
<span class="comment">;&gt;&gt; IllegalArgumentException Duplicate key: :a</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>집합은 같은 값이 중복되는 것을 허용하지 않는다. 같은 값이 있으면 예외가 발생한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; 3이 중복되어 예외가 발생한다.</span>
#{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">3</span>}
<span class="comment">;&gt;&gt; IllegalArgumentException Duplicate key: 3</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
위의 두 코드를 보면 집합이나 맵이나 중복이 있으면 Duplicate key라는 예외가
      발생한다는 것을 알 수 있다.  이 예외는 key가 중복되어서 발생한 것인데, 맵은 하나
      키가 여러 값을 가질 수 없으니 이해가 된다. 하지만 집합은 키가 아니라 값이 중복된
      것인데, 왜 Duplicate key 예외가 발생할까?  이것은 집합의 내부 구현은 맵과 같다는
      것을 의미한다. 즉 집합은 키와 값이 같은 맵으로 볼 수 있다는 것이다.  예를 들어, <code>#{1
      2 3}</code>은 <code>{1 1 2 2 3 3}</code>과 같다고 볼 수 있는 것이다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>맵은 키-값 쌍이 맞지 않으면 예외가 발생한다. 맵 안에는 항상 짝수 개의 형식(form)이 있어야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; 키 :b에 해당하는 값이 없어서 예외가 발생한다.</span>
{<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span>}
<span class="comment">;&gt;&gt; RuntimeException Map literal must contain an even number of forms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>컬렉션은 구조화된 데이터의 묶음이지만, 또한 그 자체로 값(value)이다. 따라서 데이타가 없는
컬렉션, 즉 빈(empty) 컬렉션도 값(value)이다. 아무것도 없음을 의미하는 nil과는 다르다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">=</span>  () <span class="predefined-constant">nil</span>) <span class="comment">;=&gt; false ; empty list</span>
(<span class="keyword">=</span>  [] <span class="predefined-constant">nil</span>) <span class="comment">;=&gt; false ; empty vector</span>
(<span class="keyword">=</span> #{} <span class="predefined-constant">nil</span>) <span class="comment">;=&gt; false ; empty set</span>
(<span class="keyword">=</span>  {} <span class="predefined-constant">nil</span>) <span class="comment">;=&gt; false ; empty map</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_컬렉션의_생성">1.2. 컬렉션의 생성</h3>
<div class="paragraph">
<p>리스트, 벡터, 집합, 맵 등 각 컬렉션을 동적으로 생성하는 함수들이 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">list</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)            <span class="comment">; 리스트 생성</span>
<span class="comment">;=&gt; (1 2 3)</span>

(<span class="keyword">vector</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)          <span class="comment">; 벡터 생성</span>
<span class="comment">;=&gt; [1 2 3]</span>

(<span class="keyword">hash-map</span> <span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>)    <span class="comment">; 맵 생성    </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; {:a 1 :b 2}</span>

(<span class="keyword">hash-set</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)        <span class="comment">; 집합 생성   </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="comment">;=&gt; #{1 2 3}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>map은 전혀 다른 함수이다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>set은 다른 컬렉션을 집합으로 바꾸는 함수이다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>hash-map</code>과 <code>hash-set</code>은 중복이 있으면 제거한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">hash-set</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">3</span> <span class="integer">2</span>)       <span class="comment">; 2와 3이 중복</span>
<span class="comment">;=&gt; #{1 2 3}</span>

(<span class="keyword">hash-map</span> <span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:a</span> <span class="integer">10</span>) <span class="comment">; :a키가 중복  </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; {:a 10 :b 2}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>키가 중복이 되면 나중의 것이 채택된다. 기존값을 덮어쓴다고 생각하면 된다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>vec</code>은 다른 컬렉션을 받아 벡터를 만든다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">vec</span> '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>))
<span class="comment">;=&gt; [1 2 3]</span>

(<span class="keyword">vec</span> #{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>})
<span class="comment">;=&gt; [1 3 2]</span>

(<span class="keyword">vec</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>})
<span class="comment">;=&gt; [[:c 3] [:b 2] [:a 1]]</span>

(<span class="keyword">vec</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">abcd</span><span class="delimiter">&quot;</span></span>)
<span class="comment">;=&gt; [\a \b \c \d]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>subvec</code>은 벡터에서 일부를 시작(닫힘)과 끝(열림)을 인덱스로 지정해서 뽑아낼 수 있다. 끝을 지정하지 않으면 벡터의 갯수가 기본으로 지정된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">subvec</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span> <span class="integer">6</span> <span class="integer">7</span>] <span class="integer">2</span>)
<span class="comment">;=&gt; [3 4 5 6 7]</span>

(<span class="keyword">subvec</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span> <span class="integer">6</span> <span class="integer">7</span>] <span class="integer">2</span> <span class="integer">4</span>)
<span class="comment">;=&gt; [3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>set</code>은 다른 컬렉션을 받아 집합을 만든다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">set</span> '(<span class="integer">1</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">2</span> <span class="integer">4</span> <span class="integer">5</span> <span class="integer">5</span>))      <span class="comment">; 중복은 제거된다</span>
<span class="comment">;=&gt; #{1 2 3 4 5}</span>

(<span class="keyword">set</span> [<span class="integer">1</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">2</span> <span class="integer">4</span> <span class="integer">5</span> <span class="integer">5</span>])       <span class="comment">; 중복은 제거된다</span>
<span class="comment">;=&gt; #{1 2 3 4 5}</span>

(<span class="keyword">set</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span> <span class="integer">5</span>])
<span class="comment">;=&gt; #{1 2 3 4 5}</span>

(<span class="keyword">set</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>})
<span class="comment">;=&gt; #{[:b 2] [:c 3] [:a 1]}</span>

(<span class="keyword">set</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">abcd</span><span class="delimiter">&quot;</span></span>)
<span class="comment">;=&gt; #{\a \b \c \d}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_seq">1.3. seq</h3>
<div class="paragraph">
<p>클로저에서 모든 컬렉션은 시퀀스로 취급될 수 있다. 시퀀스는 head와 tail 두 개로 구성되는데,
tail은 또 다른 시퀀스이다. 클로저에서의 시퀀스에 대해서는 뒤에서 보다 더 자세히 살펴볼
것이다.</p>
</div>
<div class="paragraph">
<p><code>seq</code> 함수는 컬렉션을 시퀀스로 변환해 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">seq</span> '(<span class="integer">1</span>))    <span class="comment">;=&gt; (1)</span>
(<span class="keyword">seq</span> [<span class="integer">1</span>])     <span class="comment">;=&gt; (1)</span>
(<span class="keyword">seq</span> #{<span class="integer">1</span>})    <span class="comment">;=&gt; (1)</span>
(<span class="keyword">seq</span> {<span class="symbol">:a</span> <span class="integer">1</span>}   <span class="comment">;=&gt; ([:a 1])</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_컬렉션에_요소_추가삭제">1.4. 컬렉션에 요소 추가/삭제</h3>
<div class="paragraph">
<p>클로저에서는 컬렉션에 요소를 추가하거나 삭제하면, 기존 컬렉션에 요소가 추가/삭제된 새로운 컬렉션이 만들어진다. 기존 컬렉션은 변하지 않고 그대로 있다. 컬렉션은 불변이다(immutable). 이것은 기존 컬렉션을 복사한 후 요소를 추가/삭제하는 것처럼 비효율적인 방식은 아니다. 구조 공유(structural sharing)이라는 기법을 통해 아주 효율적으로 불변성을 지원한다.</p>
</div>
<div class="paragraph">
<p>이러한 컬렉션의 불변성은 멀티스레딩에 근본적으로 안전한 프로그래밍을 가능하게 한다.</p>
</div>
<div class="sect3">
<h4 id="_cons">1.4.1. cons</h4>
<div class="paragraph">
<p>cons<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup> 함수는 두 개의 인수를 받아 새로운 seq를 반환한다. 반환된 seq의 head는 첫 번째 인수이고, 컬렉션인 두 번째 인수의 seq가 tail이 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">cons</span> <span class="integer">0</span> '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>))  <span class="comment">; 리스트</span>
<span class="comment">;=&gt; (0 1 2 3)</span>

(<span class="keyword">cons</span> <span class="integer">0</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>])   <span class="comment">; 벡터</span>
<span class="comment">;=&gt; (0 1 2 3)</span>

(<span class="keyword">cons</span> <span class="integer">0</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>})    <span class="comment">; 맵</span>
<span class="comment">;=&gt; (0 [:a 1] [:b 2])   </span><i class="conum" data-value="1"></i><b>(1)</b>

(<span class="keyword">cons</span> <span class="integer">0</span> #{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>})  <span class="comment">; 집합</span>
<span class="comment">;=&gt; (0 1 3 2)</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>(seq {:a 1 :b 2}) ;&#8658; ([:a 1] [:b 2])</code> 이다. 즉 맵의 seq 표현은 키-값 쌍의 튜플들이다.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_conj">1.4.2. conj</h4>
<div class="paragraph">
<p><code>conj</code><sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>함수는 컬렉션인 첫번째 인수에 두번째 인수를 추가한 새로운 컬렉션을 반환한다. <code>conj</code>는 입력 컬렉션의 형태가 보존되며, 요소 추가는 해당 컬렉션에 가장 효율적인 방식으로 처리된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">conj</span> '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>) <span class="integer">0</span>)    <span class="comment">; 리스트는 맨 앞에 추가된다.</span>
<span class="comment">;=&gt; (0 1 2 3)</span>

(<span class="keyword">conj</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">0</span>)     <span class="comment">; 벡터는 맨 뒤에 추가된다.</span>
<span class="comment">;=&gt; [1 2 3 0]</span>

(<span class="keyword">conj</span> {<span class="symbol">:a</span> <span class="integer">1</span>} [<span class="symbol">:b</span> <span class="integer">2</span>]) <span class="comment">; 맵은 키-값 쌍의 벡터 튜플로 추가된다.</span>
<span class="comment">;=&gt; {:a 1 :b 2}</span>

(<span class="keyword">conj</span> #{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>} <span class="integer">0</span>)    <span class="comment">; 집합의 경우 추가되어도 순서는 없다.</span>
<span class="comment">;=&gt; #{0 1 2 3}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>리스트는 순차 접근이기 때문에 맨 마지막이 아니라 맨 앞에 추가되는 것이 효율적이다. 반면 벡터는 임의 접근이기 때문에 맨 마지막에 추가되는 것이 효과적이다.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<code>cons</code>와 <code>conj</code>는 리스트에 요소를 추가할 때는 똑같이 맨 앞에 추가한다. 하지만 벡터에 요소를 추가할 때는 서로 다르게 <code>cons</code>는 맨 앞에, <code>conj</code>는 맨 뒤에 추가한다.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>맵의 경우에는 요소를 추가하기 위해서는 키-값 쌍의 벡터로 된 튜풀을 제공해야 한다.</p>
</div>
<div class="paragraph">
<p><code>conj</code>는 여러 개의 요소를 한 번에 추가할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">conj</span> '(<span class="integer">4</span> <span class="integer">5</span> <span class="integer">6</span>) <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)              <span class="comment">; 리스트.</span>
<span class="comment">;=&gt; (3 2 1 4 5 6)</span>

(<span class="keyword">conj</span> [<span class="integer">4</span> <span class="integer">5</span> <span class="integer">6</span>] <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)               <span class="comment">; 벡터.</span>
<span class="comment">;=&gt; [4 5 6 1 2 3)</span>

(<span class="keyword">conj</span> {<span class="symbol">:a</span> <span class="integer">1</span>} [<span class="symbol">:b</span> <span class="integer">2</span>] [<span class="symbol">:c</span> <span class="integer">3</span>] [<span class="symbol">:d</span> <span class="integer">4</span>]) <span class="comment">; 맵.</span>
<span class="comment">;=&gt; {:d 4 :c 3 :b 2 :a 1}</span>

(<span class="keyword">conj</span> #{<span class="integer">4</span> <span class="integer">5</span> <span class="integer">6</span>} <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)              <span class="comment">; 집합.</span>
<span class="comment">;=&gt; #{1 2 3 4 5 6}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_disj">1.4.3. disj</h4>
<div class="paragraph">
<p>집합의 경우 <code>disj</code><sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup> 함수로 요소를 제거한 새로운 집합을 만들 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">disj</span> #{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>} <span class="integer">2</span>)    <span class="comment">; 2를 제거.</span>
<span class="comment">;=&gt; {1 3}</span>

(<span class="keyword">disj</span> #{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>} <span class="integer">1</span> <span class="integer">3</span>)  <span class="comment">; 1과 3을 제거.</span>
<span class="comment">;=&gt; {2}</span>

(<span class="keyword">disj</span> #{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>} <span class="integer">4</span>)    <span class="comment">; 제거할 요소가 없다.</span>
<span class="comment">;=&gt; {1 2 3}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_assoc">1.4.4. assoc</h4>
<div class="paragraph">
<p>맵의 경우 요소를 추가한 새로운 맵을 만들 때 주로 <code>assoc</code><sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>을 쓴다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">assoc</span> {} <span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>)       <span class="comment">; 빈맵에 여러 요소 추가</span>
<span class="comment">;=&gt; {:c 3, :b 2, :a 1}</span>

(<span class="keyword">assoc</span> <span class="predefined-constant">nil</span> <span class="symbol">:a</span> <span class="integer">1</span>)           <span class="comment">; nil은 빈맵으로 취급된다. </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; {:a 1}</span>

(<span class="keyword">assoc</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:a</span> <span class="integer">10</span> <span class="symbol">:c</span> <span class="integer">3</span>)  <span class="comment">; 같은 키가 이미 있으면 그 값을 덮어쓴다.</span>
<span class="comment">;=&gt; {:c 3, :a 10, :b 2}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>클로저에서 <code>nil</code>이 빈맵으로 취급되는 이유는 시퀀스와 관련된 역사적 이유가 있다. 이것에 대해서는 나중에 시퀀스와 관련해서 설명하기로 한다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>assoc</code>은 벡터에도 사용될 수 있다. 이 때 키는 인덱스로 지정할 수 있다. 인덱스는 0부터 시작한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">assoc</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">0</span> <span class="integer">10</span>)      <span class="comment">; 인덱스 0에 있는 1을 10으로 바꿈.</span>
<span class="comment">;=&gt; [10 2 3]</span>

(<span class="keyword">assoc</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">2</span> '(<span class="integer">4</span> <span class="integer">6</span>))  <span class="comment">; 인덱스 2에 있는 마지막 값인 3을 '(4 6)으로 바꿈.</span>
<span class="comment">;=&gt; [1 2 (4 6)]</span>

(<span class="keyword">assoc</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">3</span> <span class="integer">10</span>)      <span class="comment">; 인덱스 3, 벡터의 끝에 10 추가. </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; [1 2 3 10]</span>

(<span class="keyword">assoc</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">4</span> <span class="integer">10</span>)      <span class="comment">; 지정한 인덱스가 없다 &gt;&gt; 예외 발생 </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="comment">;&gt;&gt; java.lang.IndexOutOfBoundsException</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong><em>맨 마지막은 끝을 의미하는 <code>nil</code>이 있다.</em></strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>맵의 경우 자동으로 추가되었다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>위에서 보는 것처럼 벡터가 <code>assoc</code>에 대해 동작하는 것을 보면, 벡터는 인덱스를 키로 하는
맵으로 취급되는 것을 알 수 있다.</p>
</div>
</div>
<div class="sect3">
<h4 id="_dissoc">1.4.5. dissoc</h4>
<div class="paragraph">
<p>맵에서 특정 키를 제거한 새로운 맵을 만들 때 주로 <code>dissoc</code>을 쓴다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">dissoc</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> c<span class="error">:</span> <span class="integer">3</span>} <span class="symbol">:b</span>)    <span class="comment">; :b 키 하나 제거.</span>
<span class="comment">;=&gt; {:a 1, :c 3}</span>


(<span class="keyword">dissoc</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> c<span class="error">:</span> <span class="integer">3</span>} <span class="symbol">:c</span> <span class="symbol">:b</span>) <span class="error">:</span> <span class="error">여</span><span class="error">러</span> <span class="error">개</span><span class="error">의</span> <span class="error">키</span> <span class="error">제</span><span class="error">거</span><span class="keyword">.</span>
<span class="comment">;=&gt; {:a 1}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>반면 <code>assoc</code>과는 다르게 <code>dissoc</code>은 벡터에는 사용할 수 없다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">dissoc</span> [<span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span>] <span class="integer">0</span>)  <span class="comment">; 잘못된 용법 &gt;&gt; 예외 발생</span>
<span class="comment">;&gt;&gt; java.lang.ClassCastException</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_assoc_in">1.4.6. assoc-in</h4>
<div class="paragraph">
<p>클로저에서는 벡터와 맵을 특히 많이 쓴다. 그런데 벡터 안에 맵이 있거나 또는 맵안에 벡터가 있는 경우 추가/삭제를 하는 것이 매우 번거로워지는데, 이럴 때 손쉽게 사용할 수 있는 것이 <code>assoc-in</code> 함수이다. 이때 내포된 컬렉션의 키를 지정하기 위해 키들의 시퀀스를 사용한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">m</span> {<span class="symbol">:a</span> {<span class="symbol">:c</span> <span class="integer">1</span>} <span class="symbol">:b</span> {<span class="symbol">:d</span> <span class="integer">2</span>}})

(<span class="keyword">assoc-in</span> m [<span class="symbol">:a</span> <span class="symbol">:c</span>] <span class="integer">10</span>)     <span class="comment">; </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; {:a {:c 10} :b {:d 2}}</span>

(<span class="keyword">assoc-in</span> m [<span class="symbol">:b</span> <span class="symbol">:e</span>] <span class="integer">3</span>)      <span class="comment">; </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="comment">;=&gt; {:a {:c 1}, :b {:e 3, :d 2}}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>두 번째 인자로 지정된 값을 세 번째 인자로 덮어 쓴다. 두번째 인자 <code>[:a :c]</code>는 대상을 지정하기 위한 키들이다. 즉 <code>:a</code>는 <code>m</code>에서 <code>{:c 1}</code>를 지정하고, <code>:c</code>는 바로 앞에서 지정된 맵인 <code>{:c 1}</code>에서 <code>1</code>을 지정한다. 이렇게 지정된 값을 <code>10</code>으로 덮어쓴다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>해당 키가 없으면 추가한다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>assoc</code>이 벡터에 대해서도 동작한 것처럼 <code>assoc-in</code>도 벡터에 대해 동작한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">assoc-in</span> {<span class="symbol">:a</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]} [<span class="symbol">:a</span> <span class="integer">0</span>] <span class="integer">10</span>)    <span class="comment">; 맵안의 벡터</span>
<span class="comment">;=&gt; {:a [10 2 3]}</span>

(<span class="keyword">assoc-in</span> [{<span class="symbol">:a</span> <span class="integer">1</span>}] [<span class="integer">0</span> <span class="symbol">:a</span>] <span class="integer">10</span>)        <span class="comment">; 벡터안의 맵</span>
<span class="comment">;=&gt; [{:a 10}]</span>

(<span class="keyword">assoc-in</span> [[<span class="integer">1</span>] [<span class="integer">2</span>] [<span class="integer">3</span>]] [<span class="integer">2</span> <span class="integer">0</span>] <span class="integer">30</span>)    <span class="comment">; 벡터안의 벡터</span>
<span class="comment">;=&gt; [[1] [2] [30]]</span>

(<span class="keyword">assoc-in</span> [[<span class="integer">1</span> <span class="integer">1</span> <span class="integer">1</span>]                   <span class="comment">; 2차원 배열</span>
           [<span class="integer">1</span> <span class="integer">1</span> <span class="integer">1</span>]
           [<span class="integer">1</span> <span class="integer">1</span> <span class="integer">1</span>]] [<span class="integer">0</span> <span class="integer">0</span>] <span class="integer">0</span>)
<span class="comment">;=&gt; [[0 1 1][1 1 1][1 1 1]]</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_컬렉션에서_요소_참조">1.5. 컬렉션에서 요소 참조</h3>
<div class="sect3">
<h4 id="_nth">1.5.1. nth</h4>
<div class="paragraph">
<p><code>nth</code>는 컬렉션에서 지정한 인덱스에 있는 값을 반환한다. 만약 해당 인덱스가 없으면 예외가 발생한다. 인덱스가 없을 때 반환할 수 있는 디폴트값을 세번째 인자로 줄 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">nth</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">0</span>)      <span class="comment">; 인덱스 0</span>
<span class="comment">;=&gt; 1</span>

(<span class="keyword">nth</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">3</span>)      <span class="comment">; 인덱스 3은 없다 &gt;&gt; 예외 발생</span>
<span class="comment">;&gt;&gt; java.lang.IndexOutOfBoundsException</span>

(<span class="keyword">nth</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">3</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">not-found</span><span class="delimiter">&quot;</span></span>)   <span class="comment">; 세번째 인자는 디폴트값.</span>
<span class="comment">;&gt;&gt; &quot;not-found&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>nth</code>는 순서가 있는 컬렉션들에 대해 동작한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">nth</span> '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>) <span class="integer">2</span>)               <span class="comment">; 리스트  </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; 3</span>

(<span class="keyword">nth</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">abcd</span><span class="delimiter">&quot;</span></span> <span class="integer">2</span>)                 <span class="comment">; 문자열</span>
<span class="comment">;=&gt; \c</span>

(<span class="keyword">nth</span> (<span class="keyword">into-array</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]) <span class="integer">2</span>)   <span class="comment">; 자바 Long 배열</span>
<span class="comment">;=&gt; 3</span>

(<span class="keyword">type</span> (<span class="keyword">into-array</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>]))
<span class="comment">;=&gt; [Ljava.lang.Long;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>리스트의 경우 인덱스가 없어서, 처음부터 하나씩 세면서 찾는다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>하지만 순서가 없는 맵과 집합에는 동작하지 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">nth</span> {<span class="symbol">:a</span> <span class="integer">1</span>} <span class="integer">0</span>)   <span class="comment">; 맵에는 인덱스를 지정할 수 없다 &gt;&gt; 예외 발생</span>
<span class="comment">;&gt;&gt; java.lang.UnsupportedOperationException</span>

(<span class="keyword">nth</span> #{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>} <span class="integer">0</span>) <span class="comment">; 집합에는 인덱스를 지정할 수 없다 &gt;&gt; 예외 발생</span>
<span class="comment">;&gt;&gt; java.lang.UnsupportedOperationException</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>반면 컬렉션에서 특정 요소의 인덱스를 구하려면 <code>indexOf</code> 자바 메소드를 호출하면 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">.</span>indexOf '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>) <span class="integer">1</span>)   <span class="comment">;=&gt; 0</span>
(<span class="keyword">.</span>indexOf  [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">2</span>)   <span class="comment">;=&gt; 1</span>
(<span class="keyword">.</span>indexOf <span class="string"><span class="delimiter">&quot;</span><span class="content">abcd</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>)   <span class="comment">;=&gt; 2</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_get">1.5.2. get</h4>
<div class="paragraph">
<p><code>get</code>은 맵에서 특정 키에 해당하는 값을 반환한다. 만약 해당키가 없으면 <code>nil</code>을
반환하는데, 디폴트값이 주어졌으면 디폴트값을 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">get</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:b</span>)    <span class="comment">; :b 키의 값을 참조</span>
<span class="comment">;;=&gt; 2</span>

(<span class="keyword">get</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:c</span>)    <span class="comment">; :c 키는 없다</span>
<span class="comment">;;=&gt; nil</span>

(<span class="keyword">get</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:c</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">not-found</span><span class="delimiter">&quot;</span></span>)  <span class="comment">; 세 번째 인자는 디폴트값</span>
<span class="comment">;;=&gt; &quot;not-found&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>벡터는 인덱스를 키로 하는 맵으로 취급될 수 있기 때문에, <code>get</code>이 동작한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">get</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">1</span>)         <span class="comment">; 인덱스 1을 키 1로 사용.</span>
<span class="comment">;=&gt; 2</span>

(<span class="keyword">get</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">5</span>)         <span class="comment">; 인덱스 5를 키 5로 사용. 하지만 없다</span>
<span class="comment">;=&gt; nil</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>인덱스가 없는 경우, nth는 예외를 던지고, get은 nil을 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">nth</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">5</span>)   <span class="comment">;&gt;&gt; java.lang.IndexOutOfBoundsException</span>
(<span class="keyword">get</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">5</span>)   <span class="comment">;=&gt; nil</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>하지만 인덱스가 없는 리스트에는 <code>get</code>이 동작하지 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">get</span> '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>) <span class="integer">0</span>)
<span class="comment">;=&gt; nil</span>

(<span class="keyword">get</span> '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>) <span class="integer">1</span>)
<span class="comment">;=&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>자바의 맵에도 <code>get</code>은 동작한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">get</span> (System/getenv) <span class="string"><span class="delimiter">&quot;</span><span class="content">SHELL</span><span class="delimiter">&quot;</span></span>)
<span class="comment">;;=&gt; &quot;/bin/bash&quot;</span>

(<span class="keyword">get</span> (System/getenv) <span class="string"><span class="delimiter">&quot;</span><span class="content">PATH</span><span class="delimiter">&quot;</span></span>)
<span class="comment">;;=&gt; &quot;/usr/local/bin:/sbin:/usr/sbin:/usr/bin:/bin&quot;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_get_in">1.5.3. get-in</h4>
<div class="paragraph">
<p>맵안의 맵처럼 내포된 맵을 참조하기 위해서는 <code>get-in</code>을 사용한다. 만약 해당값이 없으면 <code>nil</code>을, 디폴트값이 주어지면 디폴트 값을 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">m</span> {<span class="symbol">:language</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">clojure</span><span class="delimiter">&quot;</span></span>
        <span class="symbol">:authour</span> {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Rich Hickey</span><span class="delimiter">&quot;</span></span>
                  <span class="symbol">:address</span> {<span class="symbol">:city</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Austin</span><span class="delimiter">&quot;</span></span> <span class="symbol">:state</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">TX</span><span class="delimiter">&quot;</span></span>}}})

(<span class="keyword">get-in</span> m [<span class="symbol">:authour</span> <span class="symbol">:name</span>])
<span class="comment">;=&gt; &quot;Rich Hickey&quot;</span>

(<span class="keyword">get-in</span> m [<span class="symbol">:authour</span> <span class="symbol">:address</span> <span class="symbol">:city</span>])
<span class="comment">;=&gt; &quot;Austin&quot;</span>

(<span class="keyword">get-in</span> m [<span class="symbol">:authour</span> <span class="symbol">:address</span> <span class="symbol">:zip-code</span>])
<span class="comment">;=&gt; nil</span>

(<span class="keyword">get-in</span> m [<span class="symbol">:authour</span> <span class="symbol">:address</span> <span class="symbol">:zip-code</span>] <span class="string"><span class="delimiter">&quot;</span><span class="content">no zip code!</span><span class="delimiter">&quot;</span></span>)
<span class="comment">;=&gt; &quot;no zip code!&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get-in</code>은 벡터에도 동작한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">v</span> [[<span class="error">:</span><span class="integer">000</span><span class="integer">-00</span><span class="integer">-0000</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">TYPE 1</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">JACKSON</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">FRED</span><span class="delimiter">&quot;</span></span>]
        [<span class="error">:</span><span class="integer">000</span><span class="integer">-00</span><span class="integer">-0001</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">TYPE 2</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">SIMPSON</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">HOMER</span><span class="delimiter">&quot;</span></span>]
        [<span class="error">:</span><span class="integer">000</span><span class="integer">-00</span><span class="integer">-0002</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">TYPE 4</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">SMITH</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">SUSAN</span><span class="delimiter">&quot;</span></span>]])

(<span class="keyword">get-in</span> v [<span class="integer">0</span> <span class="integer">2</span>])
<span class="comment">;=&gt; &quot;JACKSON&quot;</span>

(<span class="keyword">get-in</span> [[<span class="integer">0</span> <span class="integer">1</span> <span class="integer">1</span>]
         [<span class="integer">1</span> <span class="integer">1</span> <span class="integer">1</span>]
         [<span class="integer">1</span> <span class="integer">1</span> <span class="integer">1</span>]] [<span class="integer">0</span> <span class="integer">0</span>])
<span class="comment">;=&gt; 0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_find">1.5.4. find</h4>
<div class="paragraph">
<p><code>find</code>는 맵의 엔트리(entry)를 반환한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">find</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>} <span class="symbol">:a</span>)
<span class="comment">;=&gt; [:a 1]</span>

(<span class="keyword">find</span> [<span class="symbol">:a</span> <span class="symbol">:b</span> <span class="symbol">:c</span> <span class="symbol">:d</span>] <span class="integer">2</span>)
<span class="comment">;=&gt; [2 :c]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_contains">1.5.5. contains?</h4>
<div class="paragraph">
<p><code>get</code> 함수는 해당키가 없는 경우에 <code>nil</code>을 반환한다. 하지만 조사하려는 컬렉션에 <code>nil</code>이 있는 경우 문제가 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">get</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">0</span>)         <span class="comment">;=&gt; 1</span>
(<span class="keyword">get</span> [<span class="predefined-constant">nil</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">0</span>)       <span class="comment">;=&gt; nil  </span><i class="conum" data-value="1"></i><b>(1)</b>

(<span class="keyword">get</span> {<span class="symbol">:a</span> <span class="integer">1</span>   <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:a</span>)  <span class="comment">;=&gt; 1</span>
(<span class="keyword">get</span> {<span class="symbol">:a</span> <span class="predefined-constant">nil</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:a</span>)  <span class="comment">;=&gt; nil  </span><i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>반환값이 <code>nil</code>이므로 값이 없음을 의미하지만, 실제로는 인덱스 <code>0</code>에 <code>nil</code>이라는 값이 있는 것이다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>반환값이 <code>nil</code>이므로 값이 없음을 의미하지만, 실제로는 <code>:a</code> 키에 <code>nil</code> 값이 있는 것이다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>이런 경우에 <code>contains?</code> 함수를 사용하면 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">contains?</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">0</span>)         <span class="comment">;=&gt; true</span>
(<span class="keyword">contains?</span> [<span class="predefined-constant">nil</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">0</span>)       <span class="comment">;=&gt; true</span>

(<span class="keyword">contains?</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:a</span>)    <span class="comment">;=&gt; true</span>
(<span class="keyword">contains?</span> {<span class="symbol">:a</span> <span class="predefined-constant">nil</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:a</span>)  <span class="comment">;=&gt; true</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_keys와_vals">1.5.6. keys와 vals</h4>
<div class="paragraph">
<p>맵의 경우, 키들만 뽑아내거나 혹은 값들만 뽑아내는 함수로 <code>keys</code>와 <code>vals</code>가 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">keys</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>})
<span class="comment">;=&gt; (:a :b :c)</span>

(<span class="keyword">vals</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>})
<span class="comment">;=&gt; (1 2 3)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_key와_val">1.5.7. key와 val</h4>
<div class="paragraph">
<p>사실 이것은 각 맵 엔트리(Entry)에 <code>key</code>와 <code>val</code>를 적용한 것과 같다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> <span class="keyword">key</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>})
<span class="comment">;=&gt; (:a :b :c)</span>

(<span class="keyword">map</span> <span class="keyword">val</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:c</span> <span class="integer">3</span>})
<span class="comment">;=&gt; (1 2 3)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>key</code>와 <code>val</code>은 맵의 엔트리에만 적용된다. 맵의 엔트리는 clojure.lang.IPersistentVector를 구현하기 때문에 벡터처럼 표현되기는 하지만, <code>key</code>와 <code>val</code>이 벡터에 적용되지는 않는다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">first</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>})
<span class="comment">;=&gt; [:a 1]</span>

(<span class="keyword">key</span> (<span class="keyword">first</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>}))
<span class="comment">;=&gt; :a</span>

(<span class="keyword">val</span> (<span class="keyword">first</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>}))
<span class="comment">;=&gt; 1</span>

(<span class="keyword">key</span> [<span class="symbol">:a</span> <span class="integer">1</span>])
<span class="comment">;&gt;&gt; java.lang.ClassCastException: clojure.lang.PersistentVector cannot be cast to java.util.Map$Entry</span>

(<span class="keyword">val</span> [<span class="symbol">:a</span> <span class="integer">1</span>])
<span class="comment">;&gt;&gt; java.lang.ClassCastException: clojure.lang.PersistentVector cannot be cast to java.util.Map$Entry</span>

(<span class="keyword">type</span> (<span class="keyword">first</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>}))
<span class="comment">;=&gt; clojure.lang.MapEntry</span>

(<span class="keyword">vector?</span> (<span class="keyword">first</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>}))
<span class="comment">;=&gt; true</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_직접_참조">1.5.8. 직접 참조</h4>
<div class="paragraph">
<p><code>get</code> 함수를 통하지 않고 직접 벡터, 집합, 맵으로부터 값을 읽을 수 있다. 이것이 가능한 이유는 클로저에서는 벡터, 맵, 집합이 함수처럼 동작할 수 있기 때문이다. (리스트 제외)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">([<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] <span class="integer">1</span>)          <span class="comment">; 벡터일 경우, 인자 1은 인덱스로 동작</span>
<span class="comment">;=&gt; 2</span>

({<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:a</span>)     <span class="comment">; :a 키의 값을 읽는다</span>
<span class="comment">;=&gt; 1</span>

({<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:c</span>)     <span class="comment">; :c 키는 없다</span>
<span class="comment">;=&gt; nil</span>

({<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>} <span class="symbol">:c</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">not-found</span><span class="delimiter">&quot;</span></span>)   <span class="comment">; 두 번째 인자는 디폴트값 </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; &quot;not-found&quot;</span>

(#{<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>} <span class="integer">1</span>)         <span class="comment">; 집합일 경우, 인자 1은 키로서 동작 </span><i class="conum" data-value="2"></i><b>(2)</b>
<span class="comment">;=&gt; 1</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>맵의 경우, 디폴트값을 줄 수 있다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>집합의 경우 이러한 용법은 그 집합에서의 특정값의 존재 여부를 확인하는 방법으로 쓰인다. 실제로 상당히 요긴하게 쓰인다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>이러한 컬렉션 외에 키워드나 심볼 등도 함수처럼 동작한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="symbol">:a</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>})
<span class="comment">;=&gt; 1</span>

('a {'a <span class="integer">1</span> 'b <span class="integer">2</span>})
<span class="comment">;=&gt; 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>보통 맵의 경우 위와 같은 방식으로 쓰는 것이 더 안전하다. 왜냐하면 함수가 인자로 맵을 받을 때, 때로 그 인자로 맵이 아닌 <code>nil</code>이 전달되는 경우가 심심치 않게 있는데, 그 인자를 함수로 호출하게 되면, <code>nil</code>을 함수로 호출하는 것이 되어 예외가 발생하기 때문이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">m</span> {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>})

(m <span class="symbol">:a</span>)
<span class="comment">;=&gt; 1</span>

(<span class="symbol">:a</span> m)
<span class="comment">;=&gt; 1</span>

(<span class="keyword">def</span> <span class="function">m</span> <span class="predefined-constant">nil</span>)

(m <span class="symbol">:a</span>)   <span class="comment">; nil은 함수가 아니다 &gt;&gt; 예외 발생</span>
<span class="comment">;&gt;&gt; java.lang.NullPointerException</span>

(<span class="symbol">:a</span> m)   <span class="comment">; nil이 인자로 사용된다  </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; nil</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>m</code>이 맵이 아니라 <code>nil</code>이면, 아무값도 없다는 의미로 <code>nil</code>을 반환하는 것은 정상적이다.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
어떤 것이 함수로 호출 가능한지 알아보는 방법은 <code>ifn?</code> 진위함수를 사용하는 것이다. 이 함수는 그 대상이 IFn 인터페이스를 구현했는지 여부를 확인한다. 클로저는 IFn 인터페이스를 구현한 것을 함수로서 호출한다. 실제로 키워드를 테스트해 보면, <code>(ifn? :a) ;=> true</code>, 그리고 심볼을 테스트해 보면,  <code>(ifn? 'a) ;=> true</code> 이 된다. 물론  <code>(ifn? 3) ;=> false</code>이다. 반면 진짜 함수의 구현 여부를 확인하려면 <code>fn?</code> 진위함수를 사용한다. 이 함수는 Fn 인터페이스를 구현했는지 여부를 확인한다.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_고차함수에서_직접_참조_사용하기">1.5.9. 고차함수에서 직접 참조 사용하기</h4>
<div class="paragraph">
<p>컬렉션, 키워드, 심볼 등이 함수처럼 동작하기 때문에, 이들을 고차함수(HOF, Higher Order Function)의 인자로 사용하면 코드가 매우 간결해져서, 클로저 프로그래밍에서 일상적으로 많이 사용된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">map</span> {<span class="integer">1</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">one</span><span class="delimiter">&quot;</span></span> <span class="integer">2</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span> <span class="integer">3</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">three</span><span class="delimiter">&quot;</span></span>} [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>])
<span class="comment">;=&gt; (&quot;one&quot; &quot;two&quot; &quot;three&quot;)</span>

(<span class="keyword">map</span> <span class="symbol">:age</span> [{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">31</span>}
           {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span>  <span class="symbol">:age</span> <span class="integer">24</span>}
           {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sara</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">28</span>}])
<span class="comment">;=&gt; (31 24 28)</span>

(<span class="keyword">some</span> #{<span class="integer">2</span> <span class="integer">4</span> <span class="integer">6</span>} (<span class="keyword">range</span> <span class="integer">3</span> <span class="integer">10</span>))
<span class="comment">;=&gt; 4</span>

(<span class="keyword">some</span> {<span class="integer">2</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">two</span><span class="delimiter">&quot;</span></span> <span class="integer">3</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">three</span><span class="delimiter">&quot;</span></span>} [<span class="integer">1</span> <span class="integer">3</span> <span class="integer">2</span>])
<span class="comment">;=&gt; &quot;three&quot;</span>

(<span class="keyword">remove</span> #{<span class="integer">5</span> <span class="integer">7</span>} (<span class="keyword">range</span> <span class="integer">10</span>))
<span class="comment">;=&gt; (0 1 2 3 4 6 8 9)</span>

(<span class="keyword">filter</span> <span class="symbol">:location</span> [{<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">31</span> <span class="symbol">:location</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">NYC</span><span class="delimiter">&quot;</span></span>}
                   {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span>  <span class="symbol">:age</span> <span class="integer">24</span>}
                   {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sara</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">28</span>}])
<span class="comment">;=&gt; {:name &quot;John&quot;, :age 31, :location &quot;NYC&quot;}</span></code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>여기서 주의할 점은 역시 nil이다. 고차함수의 인자로 사용된 컬렉션에 nil이 있는 경우에 의도한 바와는 다르게 동작할 수가 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">remove</span> #{<span class="integer">5</span> <span class="integer">7</span>} (<span class="keyword">cons</span> <span class="predefined-constant">nil</span> (<span class="keyword">range</span> <span class="integer">5</span>)))      <span class="comment">;=&gt; (nil 0 1 2 3 4)</span>
(<span class="keyword">remove</span> #{<span class="integer">5</span> <span class="integer">7</span> <span class="predefined-constant">nil</span>} (<span class="keyword">cons</span> <span class="predefined-constant">nil</span> (<span class="keyword">range</span> <span class="integer">5</span>)))  <span class="comment">;=&gt; (nil 0 1 2 3 4)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>만일 고차함수의 인자로 사용되는 컬렉션에 nil이 있는지 확실하지 않을 경우에는 <code>contains?</code>를 사용하는 것이 안전하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">remove</span> #(<span class="keyword">contains?</span> #{<span class="integer">5</span> <span class="integer">7</span> <span class="predefined-constant">nil</span>} %) (<span class="keyword">cons</span> <span class="predefined-constant">nil</span> (<span class="keyword">range</span> <span class="integer">5</span>)))   <span class="comment">;=&gt; (0 1 2 3 4)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>이것은 false에 대해서도 마찬지이다.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_컬렉션_진위_함수predicates">1.6. 컬렉션 진위 함수(predicates)</h3>
<div class="paragraph">
<p>다음은 각 컬렉션을 확인하는 진위함수들이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">list?</span>  '(<span class="integer">1</span>))  <span class="comment">;=&gt; true  </span><i class="conum" data-value="1"></i><b>(1)</b>
(<span class="keyword">vector?</span> [<span class="integer">1</span>])  <span class="comment">;=&gt; true  </span><i class="conum" data-value="2"></i><b>(2)</b>
(<span class="keyword">map?</span>    {<span class="integer">1</span>})  <span class="comment">;=&gt; true  </span><i class="conum" data-value="3"></i><b>(3)</b>
(<span class="keyword">set?</span>   #{<span class="integer">1</span>})  <span class="comment">;=&gt; true  </span><i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>list?는  IPersistentList 구현 여부를 확인한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>vector?는 IPersistentVector 구현 여부를 확인한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>map?은 IPersistentMap 구현 여부를 확인한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>set?은 IPersistentSet 구현 여부를 확인한다.</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. 컬렉션 비교</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-middle"></th>
<th class="tableblock halign-center valign-middle">리스트</th>
<th class="tableblock halign-center valign-middle">벡터</th>
<th class="tableblock halign-center valign-middle">집합</th>
<th class="tableblock halign-center valign-middle">맵</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">리터럴</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">'(1 2 3)</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">[1 2 3]</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">#{1 2 3}</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">{:a 1 :b 2}</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">클래스</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">clojure.lang.
PersistentList</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">clojure.lang.
PersistentVector</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">clojure.lang.
PersistentSet</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">clojure.lang.
PersistentMap</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">진위 함수</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">list?</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">vector?</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">set?</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">map?</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">인터페이스</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">IPersistentList</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">IPersistentVector</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">IPersistentSet</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">IPersistentMap</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">생성 함수</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(list 1 2 3)
;=&gt; (1 2 3)</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(vector 1 2 3)
;=&gt; [1 2 3]</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(hash-set 1 2 3)
;=&gt; #{1 2 3}</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(hash-map :a 1 :b 2)
;=&gt; {:a 1 :b 2}</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">cons</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(cons 0 '(1 2 3))
;=&gt; (0 1 2 3)</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(cons 0 [1 2 3])
;=&gt; (0 1 2 3)</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(cons 0 #{1 2 3})
;=&gt; (0 1 2 3)</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(cons :b {:a 1})
;=&gt; (:b [:a 1])</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-middle"><p class="tableblock">conj</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(conj '(1 2 3) 0)
;=&gt; (0 1 2 3)</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(conj [1 2 3] 0)
;=&gt; [1 2 3 0]</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(conj #{1 2 3} 0)
;=&gt; #{0 1 2 3}</p></td>
<td class="tableblock halign-left valign-middle"><p class="tableblock">(conj {:a 1} [:b 2])
;=&gt; {:b 2 :a 1}</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_스택_큐_트리">1.7. 스택 / 큐 / 트리</h3>
<div class="paragraph">
<p>리스트, 벡터, 맵, 집합을 보았다. 일반적으로 여러 다른 언어에서는 컬렉션으로 스택과 트리를 지원하지만, 클로저에서는 스택과 트리를 명시적인 컬렉션으로서 구현하여 제공하지는 않는다. 하지만, 리스트와 벡터를 통해서 스택과 트리를 처리할 수 있다.</p>
</div>
<div class="sect3">
<h4 id="_스택">1.7.1. 스택</h4>
<div class="paragraph">
<p>리스트와 벡터를 스택으로 사용하기 위해 <code>peek</code> 과  <code>pop</code> 함수를 제공한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">conj</span> '(<span class="integer">2</span> <span class="integer">1</span>) <span class="integer">1</span>)
<span class="comment">;=&gt; (3 2 1)</span>

(<span class="keyword">peek</span> '(<span class="integer">3</span> <span class="integer">2</span> <span class="integer">1</span>))
<span class="comment">;=&gt; 3</span>

(<span class="keyword">pop</span> '(<span class="integer">3</span> <span class="integer">2</span> <span class="integer">1</span>))
<span class="comment">;=&gt; (2 1)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">conj</span> [<span class="integer">1</span> <span class="integer">2</span>] <span class="integer">3</span>)
<span class="comment">;=&gt; [1 2 3]</span>

(<span class="keyword">peek</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>])
<span class="comment">;=&gt; 3</span>

(<span class="keyword">pop</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>])
<span class="comment">;=&gt; [1 2]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_큐">1.7.2. 큐</h4>
<div class="paragraph">
<p>클로저는 PersistentQueue를 제공한다. 리터럴이나 명시적 생성함수가 없어서 자바 호출을 직접해야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">-&gt;</span> (clojure.lang.PersistentQueue/EMPTY)
    (<span class="keyword">conj</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>)
    <span class="keyword">pop</span>)
<span class="comment">; =&gt; (2 3)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_트리">1.7.3. 트리</h4>
<div class="paragraph">
<p>트리는 zipper를 통해 구현된다.</p>
</div>
<div class="sect4">
<h5 id="_지퍼zipper">지퍼(Zipper)</h5>
<div class="sect5">
<h6 id="_트리_2">트리</h6>
<div class="paragraph">
<p>내용을 채워넣을 것.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_정렬">1.8. 정렬</h3>
<div class="sect3">
<h4 id="_sort와_sort_by">1.8.1. sort와 sort-by</h4>
<div class="paragraph">
<p><code>sort</code> 함수는 컬렉션의 아이템을 순서에 따라 정렬한 시퀀스를 반환한다. 비교자(comparator)가 주어지지 않으면, 기본적으로 <code>compare</code> 함수가 사용된다. 만일 컬렉션이 자바 배열이면, 그 순서는 수정된다. 수정을 피하려면 복사본을 사용한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">v</span> [<span class="integer">3</span> <span class="integer">4</span> <span class="integer">2</span> <span class="integer">5</span> <span class="integer">1</span>])

(<span class="keyword">sort</span> v)  <span class="comment">;=&gt; (1 2 3 4 5)</span>

(<span class="keyword">def</span> <span class="function">ja</span> (<span class="keyword">to-array</span> v))
(<span class="keyword">def</span> <span class="function">jac</span> (<span class="keyword">aclone</span> jo))       <span class="comment">; jac는 ja의 복사본</span>

(<span class="keyword">seq</span> jac)  <span class="comment">;=&gt; (3 4 2 5 1)</span>
(<span class="keyword">sort</span> jac) <span class="comment">;=&gt; (1 2 3 4 5)</span>
(<span class="keyword">seq</span> jac)  <span class="comment">;=&gt; (1 2 3 4 5)  ; 순서가 수정되었다.</span>

(<span class="keyword">seq</span> ja)   <span class="comment">;=&gt; (3 4 2 5 1)  ; 원래 순서 그대로.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sort</code> 함수에 비교자를 주면 다음과 같이 역순으로 정렬할 수도 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sort</span> <span class="keyword">&gt;</span> v)
<span class="comment">;=&gt; (5 4 3 2 1)</span>

(<span class="keyword">sort</span> #(<span class="keyword">compare</span> %2 %1) v)
<span class="comment">;=&gt; (5 4 3 2 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>compare</code> 함수는 기본으로 사용되는 비교자(Comparator)이다. 두 개의 인수 x와 y를 받는데, x &gt; y 이면 양수, x = y 이면 0, x &lt; y 이면 음수를 반환한다. 이 함수는 수, 문자, 문자열, 키워드, 심볼 등 단순값과 순서있는 컬렉션을 비교한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">compare</span> <span class="integer">1</span> <span class="integer">20</span>)            <span class="comment">;=&gt; -1</span>
(<span class="keyword">compare</span> <span class="symbol">:a</span> <span class="symbol">:b</span>)           <span class="comment">;=&gt; -1</span>
(<span class="keyword">compare</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">ab</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">abc</span><span class="delimiter">&quot;</span></span>)      <span class="comment">;=&gt; -1</span>
(comapre <span class="predefined-constant">nil</span> <span class="integer">1</span>)           <span class="comment">;=&gt; -1</span>

(<span class="keyword">compare</span> [<span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span>] [<span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span>]) <span class="comment">;=&gt; 0</span>
(<span class="keyword">compare</span> [<span class="integer">1</span> <span class="integer">2</span>] [<span class="integer">0</span> <span class="integer">1</span> <span class="integer">2</span>])   <span class="comment">;=&gt; -1</span>
(<span class="keyword">compare</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>] [<span class="integer">2</span> <span class="integer">3</span>])   <span class="comment">;=&gt; 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>사실 compare는 내부적으로 java.util.Comparator의 compareTo를 이용한다. 따라서 Comparator 인퍼에이스를 구현한 모든 클래스의 인스턴스에 적용할 수 있다.</p>
</div>
<div class="paragraph">
<p><code>sort-by</code> 함수는 <code>sort</code>와 같은데, 첫 인수로 keyfn을 받아 컬렉션의 아이템에 적용해서 반환된 결과를 기준으로 정렬한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sort-by</span> <span class="keyword">count</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">aaa</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">bb</span><span class="delimiter">&quot;</span></span> <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>])
<span class="comment">;=&gt; (&quot;c&quot; &quot;bb&quot; &quot;aaa&quot;)</span>

(<span class="keyword">sort-by</span> <span class="keyword">val</span> <span class="keyword">&gt;</span> {<span class="symbol">:foo</span> <span class="integer">7</span>, <span class="symbol">:bar</span> <span class="integer">3</span>, <span class="symbol">:baz</span> <span class="integer">5</span>})
<span class="comment">;=&gt; ([:foo 7] [:baz 5] [:bar 3])</span>

(<span class="keyword">def</span> <span class="function">v</span> [[<span class="integer">1</span> <span class="symbol">:c</span>] [<span class="integer">2</span> <span class="symbol">:b</span>] [<span class="integer">3</span> <span class="symbol">:a</span>]])

(<span class="keyword">sort-by</span> <span class="keyword">first</span> v)
<span class="comment">;=&gt; ([1 :c] [2 :b] [3 :a])</span>

(<span class="keyword">sort-by</span> <span class="keyword">first</span> v)
<span class="comment">;=&gt; ([3 :a] [2 :b] [1 :c])</span>

(<span class="keyword">sort-by</span> <span class="keyword">second</span> v)
<span class="comment">;=&gt; ([3 :a] [2 :b] [1 :c])</span>

(<span class="keyword">def</span> <span class="function">m</span> [{<span class="symbol">:id</span> <span class="integer">2</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">31</span>}
        {<span class="symbol">:id</span> <span class="integer">1</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sam</span><span class="delimiter">&quot;</span></span>  <span class="symbol">:age</span> <span class="integer">24</span>}
        {<span class="symbol">:id</span> <span class="integer">4</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Sara</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">28</span>}
        {<span class="symbol">:id</span> <span class="integer">3</span> <span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">David</span><span class="delimiter">&quot;</span></span> <span class="symbol">:age</span> <span class="integer">19</span>}])

(<span class="keyword">sort-by</span> <span class="symbol">:age</span> m)
<span class="comment">;=&gt; ({:id 3, :name &quot;David&quot;, :age 19} {:id 1, :name &quot;Sam&quot;, :age 24} {:id 4, :name &quot;Sara&quot;, :age 28} {:id 2, :name &quot;John&quot;, :age 31})</span>

(<span class="keyword">sort-by</span> <span class="symbol">:id</span> <span class="keyword">&gt;</span> m)
<span class="comment">;=&gt; ({:id 4, :name &quot;Sara&quot;, :age 28} {:id 3, :name &quot;David&quot;, :age 19} {:id 2, :name &quot;John&quot;, :age 31} {:id 1, :name &quot;Sam&quot;, :age 24})</span>

(<span class="keyword">sort-by</span> (<span class="keyword">juxt</span> <span class="symbol">:id</span> <span class="symbol">:age</span>) m)
<span class="comment">;=&gt; ({:id 1, :name &quot;Sam&quot;, :age 24} {:id 2, :name &quot;John&quot;, :age 31} {:id 3, :name &quot;David&quot;, :age 19} {:id 4, :name &quot;Sara&quot;, :age 28})</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sorted_map와_sorted_set">1.8.2. sorted-map와 sorted-set</h4>
<div class="paragraph">
<p><code>sorted-map</code>과 <code>sorted-set</code>은 <code>hashed-map</code>과 <code>hashed-set</code>과는 달리 `` 정렬된 컬렉션을 만든다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sorted-map</span> <span class="symbol">:z</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:a</span> <span class="integer">3</span>)
<span class="comment">;=&gt; {:a 3, :b 2 :z 1}</span>

(<span class="keyword">into</span> (<span class="keyword">sorted-map</span>) {<span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:a</span> <span class="integer">1</span>})
<span class="comment">;=&gt; {:a 1 :b 2}</span>

(<span class="keyword">apply</span> <span class="keyword">sorted-map</span> [<span class="symbol">:b</span> <span class="integer">2</span> <span class="symbol">:a</span> <span class="integer">1</span>])
<span class="comment">;=&gt; {:a 1 :b 2}</span>

(<span class="keyword">sorted-set</span> <span class="integer">3</span> <span class="integer">2</span> <span class="integer">1</span>)
<span class="comment">;=&gt; #{1 2 3}</span>

(<span class="keyword">into</span> (<span class="keyword">sorted-set</span>) [<span class="integer">2</span> <span class="integer">3</span> <span class="integer">1</span>])
<span class="comment">;=&gt; #(1 2 3)</span>

(<span class="keyword">apply</span> <span class="keyword">sorted-set</span> [<span class="integer">2</span> <span class="integer">3</span> <span class="integer">1</span>])
<span class="comment">;=&gt; #(1 2 3)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sorted_map_by와_sorted_set_by">1.8.3. sorted-map-by와 sorted-set-by</h4>
<div class="paragraph">
<p><code>sorted-map-by</code>와 <code>sorted-set-by</code>은 비교자를 첫 인수로 받는다는 점만 빼고는,  <code>sorted-map</code>와 <code>sorted-set</code> 와 같다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sorted-map-by</span> <span class="keyword">&gt;</span> <span class="integer">1</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="integer">2</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>, <span class="integer">3</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>)
<span class="comment">;=&gt; {3 &quot;c&quot;, 2 &quot;b&quot;, 1 &quot;a&quot;}</span>

(<span class="keyword">into</span> (<span class="keyword">sorted-map-by</span> <span class="keyword">&gt;</span>)  {<span class="integer">1</span> <span class="symbol">:a</span>  <span class="integer">2</span> <span class="symbol">:b</span>  <span class="integer">3</span> <span class="symbol">:c</span>} )
<span class="comment">;=&gt; {3 :c, 2 :b, 1 :a}</span>

(<span class="keyword">apply</span> (<span class="keyword">sorted-map-by</span> <span class="keyword">&gt;</span>)  [<span class="integer">1</span> <span class="symbol">:a</span>  <span class="integer">2</span> <span class="symbol">:b</span>  <span class="integer">3</span> <span class="symbol">:c</span>])
<span class="comment">;=&gt; {3 :c, 2 :b, 1 :a}</span>

(<span class="keyword">sorted-set-by</span> <span class="keyword">&gt;</span> <span class="integer">3</span> <span class="integer">5</span> <span class="integer">8</span> <span class="integer">2</span> <span class="integer">1</span>)
<span class="comment">;=&gt; #{8 5 3 2 1}</span>

(<span class="keyword">into</span> (<span class="keyword">sorted-set-by</span> <span class="keyword">&gt;</span>) [<span class="integer">3</span> <span class="integer">5</span> <span class="integer">8</span> <span class="integer">2</span> <span class="integer">1</span>])
<span class="comment">;=&gt; #{8 5 3 2 1}</span>

(<span class="keyword">apply</span> <span class="keyword">sorted-set-by</span> <span class="keyword">&gt;</span> [<span class="integer">3</span> <span class="integer">5</span> <span class="integer">8</span> <span class="integer">2</span> <span class="integer">1</span>])
<span class="comment">;=&gt; #{8 5 3 2 1}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reverse_rseq">1.8.4. reverse / rseq</h4>
<div class="paragraph">
<p><code>reverse</code> 함수는 컬렉션의 순서가 뒤집힌 시퀀스를 lazy가 아니다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">reverse</span> '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>))
<span class="comment">;=&gt; (3 2 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>rseq</code> 함수는 컬렉션의 순서를 뒤집힌 시퀀스를 상수 시간에 반환한다. 컬렉션은 clojure.lang.Reversible 인터페이스를 구현한 벡터나 sorted-set, sorted-map 등 이어야 한다. 이것은 <code>reversable?</code> 진위함수로 확인할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">reversible?</span> ())            <span class="comment">;=&gt; false</span>
(<span class="keyword">reversible?</span> [])            <span class="comment">;=&gt; true</span>
(<span class="keyword">reversible?</span> {})            <span class="comment">;=&gt; false</span>
(<span class="keyword">reversible?</span> #{})           <span class="comment">;=&gt; false</span>
(<span class="keyword">reversible?</span> (<span class="keyword">sorted-map</span>))  <span class="comment">;=&gt; true</span>
(<span class="keyword">reversible?</span> (<span class="keyword">sorted-set</span>))  <span class="comment">;=&gt; true</span>

(<span class="keyword">rseq</span> '(<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>))
<span class="comment">;=&gt; java.lang.ClassCastException: clojure.lang.PersistentList cannot be cast to clojure.lang.Reversible</span>

(<span class="keyword">rseq</span> [<span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span>])
<span class="comment">;=&gt; (3 2 1)</span>

(<span class="keyword">rseq</span> (<span class="keyword">into</span> (<span class="keyword">sorted-map</span>) {<span class="symbol">:a</span> <span class="integer">1</span> <span class="symbol">:b</span> <span class="integer">2</span>}))
<span class="comment">;=&gt; ([:b 2] [:a 1])</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_subseq_rsubseq">1.8.5. subseq / rsubseq</h4>
<div class="paragraph">
<p><code>subseq</code>는 정렬 컬렉션(<code>sorted?</code> 진위함수로 true가 되는 컬렉션: sorted-map과 sorted-set)에서 특정 조건에 맞는 요소들만 추려서 정렬한 시퀀스를 반환한다. <code>rsubseq</code>는 <code>subseq</code>와 같은데 역전된 시퀀스를 반환한다. <code>subseq</code>와 <code>rsubseq</code>의 비교 대상은 컬렉션의 값이 아니라 키이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sorted?</span> (<span class="keyword">sorted-map</span>))  <span class="comment">;=&gt; true</span>
(<span class="keyword">sorted?</span> (<span class="keyword">sorted-set</span>))  <span class="comment">;=&gt; true</span>
(<span class="keyword">sorted?</span> (<span class="keyword">sort</span> [<span class="integer">1</span> <span class="integer">2</span>]))  <span class="comment">;=&gt; false</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure"><span class="comment">;; sorted-map에 적용하는 경우</span>
(<span class="keyword">def</span> <span class="function">sm</span> (<span class="keyword">sorted-map</span> <span class="symbol">:z</span> <span class="integer">37</span> <span class="symbol">:x</span> <span class="integer">20</span> <span class="symbol">:y</span> <span class="integer">71</span> <span class="symbol">:b</span> <span class="integer">8</span> <span class="symbol">:a</span> <span class="integer">13</span> <span class="symbol">:c</span> <span class="integer">55</span>))

sm
<span class="comment">;=&gt; {:a 13, :b 8, :c 55, :x 20, :y 71, :z 37}</span>

(<span class="keyword">subseq</span> sm <span class="keyword">&lt;=</span> <span class="symbol">:c</span>)
<span class="comment">;=&gt; ([:a 13] [:b 8] [:c 55])</span>

(<span class="keyword">subseq</span> sm <span class="keyword">&gt;</span> <span class="symbol">:b</span> <span class="keyword">&lt;=</span> <span class="symbol">:y</span>)
<span class="comment">;=&gt; ([:c 55] [:x 20] [:y 71])</span>

(<span class="keyword">rsubseq</span> sm <span class="keyword">&gt;</span> <span class="symbol">:b</span> <span class="keyword">&lt;=</span> <span class="symbol">:y</span>)
<span class="comment">;=&gt; ([:y 71] [:x 20] [:c 55])</span>


<span class="comment">;; sorted-set에 적용하는 경우</span>
(<span class="keyword">subseq</span> (<span class="keyword">sorted-set</span> <span class="integer">1</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">4</span>) <span class="keyword">&gt;</span> <span class="integer">2</span>)
<span class="comment">;=&gt; (3 4)</span></code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">비교함수</div>
<div class="paragraph">
<p><code>compare</code> 함수는 정렬과 관련된 모든 클로저 코어 함수들에서 사용되는 디폴트 비교함수이다. 이 함수는 내부적으로는 java.lang.Comparable 인터페이스의 compareTo 함수를 사용한다. 따라서 Comparable 인터페이스를 구현한 값들은 모두 compare의 대상이 될 수 있다. <code>nil</code>은 가장 낮은 값으로 평가된다.</p>
</div>
<div class="paragraph">
<p><code>instance?</code> 함수로 Comparable 인터페이스를 구현했는지 여부를 확인해 볼 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">instance?</span> java.lang.Comparable <span class="integer">1</span>)              <span class="comment">;=&gt; true</span>
(<span class="keyword">instance?</span> java.lang.Comparable <span class="symbol">:a</span>)             <span class="comment">;=&gt; true</span>
(<span class="keyword">instance?</span> java.lang.Comparable <span class="char">\a</span>)             <span class="comment">;=&gt; true</span>
(<span class="keyword">instance?</span> java.lang.Comparable <span class="string"><span class="delimiter">&quot;</span><span class="content">abcd</span><span class="delimiter">&quot;</span></span>)         <span class="comment">;=&gt; true</span>
(<span class="keyword">instance?</span> java.lang.Comparable 'a)             <span class="comment">;=&gt; true</span>
(<span class="keyword">instance?</span> java.lang.Comparable [])             <span class="comment">;=&gt; true</span>

(<span class="keyword">instance?</span> java.lang.Comparable ())             <span class="comment">;=&gt; false</span>
(<span class="keyword">instance?</span> java.lang.Comparable {})             <span class="comment">;=&gt; false</span>
(<span class="keyword">instance?</span> java.lang.Comparable #{})            <span class="comment">;=&gt; false</span>
(<span class="keyword">instance?</span> java.lang.Comparable (<span class="keyword">sorted-map</span>))   <span class="comment">;=&gt; false</span>
(<span class="keyword">instance?</span> java.lang.Comparable (<span class="keyword">sorted-set</span>))   <span class="comment">;=&gt; false</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>만약 <code>compare</code> 함수가 비교할 수 없는 값들이 있다면, 비교 함수를 직접 만들어야 할 것이다. 다음은 비교 함수를 만드는데 필요한 가이드를 제시한다.</p>
</div>
<div class="paragraph">
<p>우선 <code>compare</code> 함수 자체를 활용해 보는 것이다. 예를 들어 다음은 역전된 순서로 비교한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sort</span> [<span class="integer">4</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">1</span>])
<span class="comment">;=&gt; (1 2 3 4)</span>

(<span class="keyword">sort</span> #(<span class="keyword">compare</span> %2 %1) [<span class="integer">4</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">1</span>])
<span class="comment">;=&gt; (4 3 2 1)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>다음은 한 번에 여러가지 항목들을 비교한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="function">john1</span> {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:salary</span> <span class="float">35000.00</span>, <span class="symbol">:company</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Acme</span><span class="delimiter">&quot;</span></span> })
(<span class="keyword">def</span> <span class="function">mary</span>  {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:salary</span> <span class="float">35000.00</span>, <span class="symbol">:company</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mars Inc</span><span class="delimiter">&quot;</span></span> })
(<span class="keyword">def</span> <span class="function">john2</span> {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:salary</span> <span class="float">40000.00</span>, <span class="symbol">:company</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Venus Co</span><span class="delimiter">&quot;</span></span> })
(<span class="keyword">def</span> <span class="function">john3</span> {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:salary</span> <span class="float">30000.00</span>, <span class="symbol">:company</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Asteroids-R-Us</span><span class="delimiter">&quot;</span></span> })
(<span class="keyword">def</span> <span class="function">people</span> [john1 mary john2 john3])

(<span class="keyword">defn</span> <span class="function">by-salary-name-co2</span> [x y]
  (<span class="keyword">compare</span> [(<span class="symbol">:salary</span> y) (<span class="symbol">:name</span> x) (<span class="symbol">:company</span> x)]
           [(<span class="symbol">:salary</span> x) (<span class="symbol">:name</span> y) (<span class="symbol">:company</span> y)]))

(pprint (<span class="keyword">sort</span> by-salary-name-co2 people))
<span class="comment">;=&gt; ({:name &quot;John&quot;, :salary 40000.0, :company &quot;Venus Co&quot;}</span>
     {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:salary</span> <span class="float">35000.0</span>, <span class="symbol">:company</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Acme</span><span class="delimiter">&quot;</span></span>}
     {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:salary</span> <span class="float">35000.0</span>, <span class="symbol">:company</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Mars Inc</span><span class="delimiter">&quot;</span></span>}
     {<span class="symbol">:name</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>, <span class="symbol">:salary</span> <span class="float">30000.0</span>, <span class="symbol">:company</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Asteroids-R-Us</span><span class="delimiter">&quot;</span></span>})</code></pre>
</div>
</div>
<div class="paragraph">
<p>벡터는 길이가 길면 큰 값인데, 길이가 같으면 내부값들 차례로 비교해서 결정한다.</p>
</div>
<div class="paragraph">
<p><strong>2단 비교 함수</strong></p>
</div>
<div class="paragraph">
<p>자바의 Comparable 인터페이스는 3단 비교 방식으로, 크면 양의 정수, 작으면 음의 정수, 같으면 0을 반환한다. 하지만 true/false를 반환하는 진위함수를 2단 비교 함수로 사용할 수 있다. 이미 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> 등의 진위함수들이 사용되는 것을 보았을 것이다. 이런 진위함수는 다음과 같은 방식으로 쉽게 3단 비교가 가능하다. 만약 진위함수가 x와 y를 비교해서 true를 반환하면 -1을, 그렇지 않으면 순서를 바꿔서 다시 y와 x를 비교해서 true를 반환하면 1을, 그렇지 않으면 0을 반환하는 것이다. 아래의 코드가 그 예시를 보여준다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">if</span> (bool-cmp-fn x y)    <span class="comment">; 처음에는 x y 순서로 비교한다.</span>
  <span class="integer">-1</span>     <span class="comment">; x &lt; y</span>
  (<span class="keyword">if</span> (bool-cmp-fn y x)  <span class="comment">; 다음에는 y x 순서로 비교한다.</span>
    <span class="integer">1</span>    <span class="comment">; x &gt; y</span>
    <span class="integer">0</span>))  <span class="comment">; x = y</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>comparator</code>는 2단 비교 함수를 3단 비교 함수로 바꾸어준다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">def</span> <span class="integer">3</span>-way-less-than (<span class="keyword">comparator</span> <span class="keyword">&lt;</span>))

(<span class="integer">3</span>-way-less-than <span class="integer">1</span> <span class="integer">2</span>)  <span class="comment">;=&gt; -1</span>
(<span class="integer">3</span>-way-less-than <span class="integer">2</span> <span class="integer">1</span>)  <span class="comment">;=&gt; 1</span>
(<span class="integer">3</span>-way-less-than <span class="integer">1</span> <span class="integer">1</span>)  <span class="comment">;=&gt; 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>비교함수로 사용되는 클로저의 코어 함수들은 Comparator 인터페이스를 이미 구현했기 때문에, 정렬 관련 작업을 하는 클로저 코어 함수들은 이런 비교함수들을 받아서 내부적으로 2단 비교 함수를 받아서 이런식으로 3단 비교 함수 바꿔서 사용한다.</p>
</div>
<div class="paragraph">
<p><strong>주의: 값의 일부만 비교하면 문제가 될 수 있다</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">by-2nd</span> [a b]
  (<span class="keyword">compare</span> (<span class="keyword">second</span> a) (<span class="keyword">second</span> b)))  <span class="comment">; 튜플의 두 번째 요소만 검사한다.</span>

(<span class="keyword">sorted-set-by</span> by-2nd [<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>] [<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>] [<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>])   <i class="conum" data-value="1"></i><b>(1)</b>
<span class="comment">;=&gt; #{[&quot;a&quot; 1]}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>두 번째 요소가 모두 1로 같기 때문에 처음 <code>["a" 1]</code>이 집합에 들어간 후, 나머지들은 중복이라서 포함되지 못한 것이다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>만일 이때 <code>compare</code>를 <code>&lt;=</code>로 바꿘주면 포함되기는 하지만 다른 문제가 발행한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">defn</span> <span class="function">by-2nd-&lt;</span><span class="keyword">=</span> [a b]
  (<span class="keyword">&lt;=</span> (<span class="keyword">second</span> a) (<span class="keyword">second</span> b)))  <span class="comment">; compare 대신 &lt;=로 바꾸었다.</span>

(<span class="keyword">def</span> <span class="function">sset</span> (<span class="keyword">sorted-set-by</span> by-2nd-&lt;<span class="keyword">=</span> [<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>] [<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>] [<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>]))   <i class="conum" data-value="1"></i><b>(1)</b>

sset
<span class="comment">;=&gt; #{[&quot;c&quot; 1] [&quot;b&quot; 1] [&quot;a&quot; 1]}</span>

(sset [<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>])  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="comment">;=&gt; nil</span>
(sset [<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>])
<span class="comment">;=&gt; nil</span>
(sset [<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span> <span class="integer">1</span>])
<span class="comment">;=&gt; nil</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>["a" 1]</code>이 <code>["b" 1]</code> 보다 작다라는 검사에서 true가 되기 때문에, 이제 집합에 포함되기는 한다.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>하지만 <code>["c" 1]</code> 끼리 검사할 때도 작다라는 검사에서 true가 되기 때문에, 집합에 값이 있어도 찾지를 못한다.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>주의: 비교 함수에 <code>-</code>를 사용해서 값이 차이로 비교할 때 문제가 될 수 있다</strong></p>
</div>
<div class="paragraph">
<p><code>compare</code> 함수가 3단 비교로서, 크면 양의 정수, 작으면 음의 정수, 같으면 0을 반환하기 때문에 두 수를 다음과 같이 <code>-</code> 함수를 사용해서 구현할 수도 있을 것이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sort</span> #(<span class="keyword">-</span> %1 %2) [<span class="integer">4</span> <span class="integer">2</span> <span class="integer">3</span> <span class="integer">1</span>])
<span class="comment">;=&gt; (1 2 3 4)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>이렇게 <code>-</code> 사용하게 되면 예기치 않은 문제가 발생할 수 있다. 예를 들어 다음과 같이 자바 Int 값의 최소값과 최대값이 비교 대상이 되는 경우이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sort</span> #(<span class="keyword">-</span> %1 %2) [<span class="integer">0</span> <span class="integer">1</span> Integer/MIN_VALUE Integer/MAX_VALUE <span class="integer">3</span> <span class="integer">4</span>])
<span class="comment">;=&gt; (0 1 3 4 2147483647 -21474836)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>다음으로는 실수를 비교하는 경우이다. 3단 비교함수는 자바의 32비트 Int로 반환하는데, 1보다 작은 실수는 Int로 변환되면서 0으로 캐스팅되기 때문에, 모두 같다고 비교하게 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">sort</span> #(<span class="keyword">-</span> %1 %2) [<span class="float">1.0</span> <span class="float">0.9</span> <span class="float">0.8</span> <span class="float">0.7</span>])
<span class="comment">;=&gt; (1.0 0.9 0.8 0.7)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">시퀀스와 nil</div>
<div class="paragraph">
<p>클로저에서 <code>nil</code>은 하나의 값으로서 <code>()</code>(빈 리스트) 과는 다르다. 그러나 때때로 <code>nil</code>은 <code>()</code>로 취급된다. 이것은 클로저가 처음 만들어질 때 커먼 리스프의 nil의 개념을 그대로 따르다가 나중에는 버린 역사적인 이유 때문이다.</p>
</div>
<div class="paragraph">
<p>클로저는 처음에는 커먼 리스프의 전통을 따랐는데, 이 전통에 따르면 empty list와 nil은 같은 것이었다. 보다 정확하게 말하자면 커먼 리스프에서는 리스트의 끝을 표시하기 위해 nil을 사용했는데, nil이 리스트의 끝을 의미하게 되면서 자연스럽게 ()도 의미하게 된 것이다. ()는 단지 nil의 별칭이었을 뿐이었지 하나의 값으로 존재하지는 않았다고 보는 것이 맞다. 그래서 클로저도 처음에는 커먼 리스프처럼 nil과 ()을 섞어서 쓰는 함수들이 있엇던 것이다.</p>
</div>
<div class="paragraph">
<p>하지만 이러한 커먼 리스프의 nil에 대한 전통은 Lazyness를 고려하게 되면 문제가 되었다. 왜냐하면 어떤 것이 리스트인지 아닌지 판별하기 위해서는 first를 적용해 보아야 하는데, 이렇게 되면  항상 처음 요소는 실행한 상태가 되어야 하기 때문이다.</p>
</div>
<div class="paragraph">
<p>이러한 점을 철저히 조사를 한 후, 클로저는 자신의 시퀀스 개념을 정립/고안하게 되었다. 그것은 empty 상태를 가질 수 있으며, seq를 적용한 이후에야 nil인지 뭔가 내용이 있는지를 확인할 수 있다는 것이다. 하지만 클로저는 하위 호환성을 위해 nil을 empty list처럼 다루는 코드들을 유지하게 된 것이다. cons를 그런 것중 하나이다.</p>
</div>
<div class="paragraph">
<p>그 전통에서 리스트에 대해 생각한 것은 리스트는 first와 rest를 갖는 그런 것이었다. empty list는 first와 rest가 없기 때문에 리스트가 아니었다. 그런 리스트는 존재할 수 없는 것이다.</p>
</div>
<div class="paragraph">
<p>하지만 first를 적용해 보지 않고서는 그것이 리스트인지를 판별할 수 없었다. 이러한 이유로 인해서 지연계산을 지원하기가 어렵게 된다. 왜냐하면 무엇인가를 하기 전에 먼저 first를 해봐야 하기 때문이다.</p>
</div>
<div class="paragraph">
<p>이러한 점을 철저히 조사를 한 후, 클로저는 자신의 시퀀스 개념을 정립/고안하게 되었다. 그것은 empty 상태를 가질 수 있으며, seq를 적용한 이후에야 nil인지 뭔가 내용이 있는지를 확인할 수 있다는 것이다. 하지만 클로저는 하위 호환성을 위해 nil을 empty list처럼 다루는 코드들을 유지하게 된 것이다. cons를 그런 것중 하나이다.</p>
</div>
<div class="paragraph">
<p>처음 클로저는 커멈 리스프(Common Lisp)의 cons cell에서 시퀀스 개념을 많이 빌려왔다. 커먼 리스프에서는 empty list라는 개념이 없었다. list의 끝을 의미하는 nil만이 있었다. ()는 nil의 별칭(alias)였을 뿐이지, empty list를 의미하는 것이 아니었다. 즉 커먼 리스프에서는 뭔가 내용이 있는 리스프이거나 아무것도 아닌 nil만이 있었지, empty list라는 개념 자체가 없었던 것이다. 아니면 nil은 아무것도 아님을 의미하거마 논리적 거짓을 의미하거나 empty list를 의미했다. 시퀀스는 first와 rest로 된 것이다.</p>
</div>
<div class="paragraph">
<p>시퀀스 개념은 다른 리스프와 많이 다른 점이다. 클로저는 구체적인 자료구조에 의존하지 않는다. 자료구조들은 모두 시퀀스라는 추상을 통해 접근된다. 클로저는 구체적인 자료구조가 아니라 시퀀스라는 추상을 통해 구현된다. 빈 컬렉션에 대해 시퀀스를 요청하면, 내용이 없기 때문에, 시퀀스를 만들어 낼 수 없어 nil을 반환한다.</p>
</div>
<div class="paragraph">
<p>the symbol nil is used to represent both the empty list and the ``false'' value for Boolean tests.</p>
</div>
<div class="paragraph">
<p>커먼 리스프에서 nil은 4가지 역할을 한다.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>심볼</p>
</li>
<li>
<p>false</p>
</li>
<li>
<p>empty list</p>
</li>
<li>
<p>don&#8217;t care</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="commom list"></code></pre>
</div>
</div>
<div class="paragraph">
<p>처음 클로저는 커먼 리스프의 이러한 점을 수용하였다. 그러나 언어에 대한 고민이 깊어지면서 이러한 점이 지연계산(Lazyness)에 문제가 된다는 사실을 발견하게 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="clojure">(<span class="keyword">=</span> <span class="predefined-constant">nil</span> ())   <span class="comment">;=&gt; false</span>

(<span class="keyword">first</span> ())   <span class="comment">;=&gt; nil</span>
(<span class="keyword">first</span> <span class="predefined-constant">nil</span>)  <span class="comment">;=&gt; nil</span>
(<span class="keyword">rest</span> ())    <span class="comment">;=&gt; ()</span>
(<span class="keyword">rest</span> <span class="predefined-constant">nil</span>)   <span class="comment">;=&gt; ()</span>
(<span class="keyword">cons</span> <span class="integer">1</span> <span class="predefined-constant">nil</span>) <span class="comment">;=&gt; (1)</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://gist.github.com/Engelberg/e54f719e96a56113d001" class="bare">https://gist.github.com/Engelberg/e54f719e96a56113d001</a></p>
</li>
<li>
<p><a href="http://clojure.org/lisps" class="bare">http://clojure.org/lisps</a></p>
</li>
<li>
<p><a href="http://clojure.org/lazy" class="bare">http://clojure.org/lazy</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. 클로저와 다른 리스프 언어, 즉 커먼 리스프나 스킴 등과의 비교는 다음 링크롤 보라. <a href="http://clojure.org/lisps" class="bare">http://clojure.org/lisps</a>
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. construct의 준말
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. conjoin의 준말
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. disjoin의 준말
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. associate의 준말
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-12-14 02:45:19 UTC
</div>
</div>
</body>
</html>